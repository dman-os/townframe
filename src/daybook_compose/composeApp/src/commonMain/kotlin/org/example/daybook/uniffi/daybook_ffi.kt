// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

@file:Suppress("NAME_SHADOWING")
@file:OptIn(kotlin.time.ExperimentalTime::class, kotlin.uuid.ExperimentalUuidApi::class)

package org.example.daybook.uniffi

// Common helper code.
//
// Ideally this would live in a separate .kt file where it can be unittested etc
// in isolation, and perhaps even published as a re-useable package.
//
// However, it's important that the details of how this helper code works (e.g. the
// way that different builtin types are passed across the FFI) exactly match what's
// expected by the Rust code on the other side of the interface. In practice right
// now that means coming from the exact some version of `uniffi` that was used to
// compile the Rust component. The easiest way to ensure this is to bundle the Kotlin
// helpers directly inline like we're doing here.

import com.sun.jna.Library
import com.sun.jna.IntegerType
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.Structure
import com.sun.jna.Callback
import com.sun.jna.ptr.*
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.CharBuffer
import java.nio.charset.CodingErrorAction
import java.util.concurrent.atomic.AtomicLong
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicBoolean
import kotlin.coroutines.resume
import kotlin.time.Instant
import kotlin.uuid.Uuid
import kotlinx.coroutines.CancellableContinuation
import kotlinx.coroutines.DelicateCoroutinesApi
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.suspendCancellableCoroutine
import org.example.daybook.uniffi.core.ConfigEvent
import org.example.daybook.uniffi.core.CreateProgressTaskArgs
import org.example.daybook.uniffi.core.DispatchEvent
import org.example.daybook.uniffi.core.DocNBranches
import org.example.daybook.uniffi.core.DrawerEvent
import org.example.daybook.uniffi.core.FacetDisplayHint
import org.example.daybook.uniffi.core.FfiConverterTypeConfigEvent
import org.example.daybook.uniffi.core.FfiConverterTypeCreateProgressTaskArgs
import org.example.daybook.uniffi.core.FfiConverterTypeDispatchEvent
import org.example.daybook.uniffi.core.FfiConverterTypeDocNBranches
import org.example.daybook.uniffi.core.FfiConverterTypeDrawerEvent
import org.example.daybook.uniffi.core.FfiConverterTypeFacetDisplayHint
import org.example.daybook.uniffi.core.FfiConverterTypeListenerRegistration
import org.example.daybook.uniffi.core.FfiConverterTypePanel
import org.example.daybook.uniffi.core.FfiConverterTypePlugsEvent
import org.example.daybook.uniffi.core.FfiConverterTypeProgressEvent
import org.example.daybook.uniffi.core.FfiConverterTypeProgressRetentionPolicy
import org.example.daybook.uniffi.core.FfiConverterTypeProgressTask
import org.example.daybook.uniffi.core.FfiConverterTypeProgressUpdate
import org.example.daybook.uniffi.core.FfiConverterTypeProgressUpdateEntry
import org.example.daybook.uniffi.core.FfiConverterTypeTab
import org.example.daybook.uniffi.core.FfiConverterTypeTable
import org.example.daybook.uniffi.core.FfiConverterTypeTablesEvent
import org.example.daybook.uniffi.core.FfiConverterTypeTablesPatches
import org.example.daybook.uniffi.core.FfiConverterTypeUpdateDocArgsV2
import org.example.daybook.uniffi.core.FfiConverterTypeWindow
import org.example.daybook.uniffi.core.ListenerRegistration
import org.example.daybook.uniffi.core.Panel
import org.example.daybook.uniffi.core.PlugsEvent
import org.example.daybook.uniffi.core.ProgressEvent
import org.example.daybook.uniffi.core.ProgressRetentionPolicy
import org.example.daybook.uniffi.core.ProgressTask
import org.example.daybook.uniffi.core.ProgressUpdate
import org.example.daybook.uniffi.core.ProgressUpdateEntry
import org.example.daybook.uniffi.core.Tab
import org.example.daybook.uniffi.core.Table
import org.example.daybook.uniffi.core.TablesEvent
import org.example.daybook.uniffi.core.TablesPatches
import org.example.daybook.uniffi.core.UpdateDocArgsV2
import org.example.daybook.uniffi.core.Window
import org.example.daybook.uniffi.types.AddDocArgs
import org.example.daybook.uniffi.types.Doc
import org.example.daybook.uniffi.types.DocPatch
import org.example.daybook.uniffi.types.FfiConverterTypeAddDocArgs
import org.example.daybook.uniffi.types.FfiConverterTypeDoc
import org.example.daybook.uniffi.types.FfiConverterTypeDocPatch
import org.example.daybook.uniffi.core.RustBuffer as RustBufferConfigEvent
import org.example.daybook.uniffi.core.RustBuffer as RustBufferCreateProgressTaskArgs
import org.example.daybook.uniffi.core.RustBuffer as RustBufferDispatchEvent
import org.example.daybook.uniffi.core.RustBuffer as RustBufferDocNBranches
import org.example.daybook.uniffi.core.RustBuffer as RustBufferDrawerEvent
import org.example.daybook.uniffi.core.RustBuffer as RustBufferFacetDisplayHint
import org.example.daybook.uniffi.core.RustBuffer as RustBufferListenerRegistration
import org.example.daybook.uniffi.core.RustBuffer as RustBufferPanel
import org.example.daybook.uniffi.core.RustBuffer as RustBufferPlugsEvent
import org.example.daybook.uniffi.core.RustBuffer as RustBufferProgressEvent
import org.example.daybook.uniffi.core.RustBuffer as RustBufferProgressRetentionPolicy
import org.example.daybook.uniffi.core.RustBuffer as RustBufferProgressTask
import org.example.daybook.uniffi.core.RustBuffer as RustBufferProgressUpdate
import org.example.daybook.uniffi.core.RustBuffer as RustBufferProgressUpdateEntry
import org.example.daybook.uniffi.core.RustBuffer as RustBufferTab
import org.example.daybook.uniffi.core.RustBuffer as RustBufferTable
import org.example.daybook.uniffi.core.RustBuffer as RustBufferTablesEvent
import org.example.daybook.uniffi.core.RustBuffer as RustBufferTablesPatches
import org.example.daybook.uniffi.core.RustBuffer as RustBufferUpdateDocArgsV2
import org.example.daybook.uniffi.core.RustBuffer as RustBufferWindow
import org.example.daybook.uniffi.types.RustBuffer as RustBufferAddDocArgs
import org.example.daybook.uniffi.types.RustBuffer as RustBufferDoc
import org.example.daybook.uniffi.types.RustBuffer as RustBufferDocPatch

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

/**
 * @suppress
 */
@Structure.FieldOrder("capacity", "len", "data")
open class RustBuffer : Structure() {
    // Note: `capacity` and `len` are actually `ULong` values, but JVM only supports signed values.
    // When dealing with these fields, make sure to call `toULong()`.
    @JvmField var capacity: Long = 0
    @JvmField var len: Long = 0
    @JvmField var data: Pointer? = null

    class ByValue: RustBuffer(), Structure.ByValue
    class ByReference: RustBuffer(), Structure.ByReference

   internal fun setValue(other: RustBuffer) {
        capacity = other.capacity
        len = other.len
        data = other.data
    }

    companion object {
        internal fun alloc(size: ULong = 0UL) = uniffiRustCall() { status ->
            // Note: need to convert the size to a `Long` value to make this work with JVM.
            UniffiLib.ffi_daybook_ffi_rustbuffer_alloc(size.toLong(), status)
        }.also {
            if(it.data == null) {
               throw RuntimeException("RustBuffer.alloc() returned null data pointer (size=${size})")
           }
        }

        internal fun create(capacity: ULong, len: ULong, data: Pointer?): RustBuffer.ByValue {
            var buf = RustBuffer.ByValue()
            buf.capacity = capacity.toLong()
            buf.len = len.toLong()
            buf.data = data
            return buf
        }

        internal fun free(buf: RustBuffer.ByValue) = uniffiRustCall() { status ->
            UniffiLib.ffi_daybook_ffi_rustbuffer_free(buf, status)
        }
    }

    @Suppress("TooGenericExceptionThrown")
    fun asByteBuffer() =
        this.data?.getByteBuffer(0, this.len)?.also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to in the JVM, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

@Structure.FieldOrder("len", "data")
internal open class ForeignBytes : Structure() {
    @JvmField var len: Int = 0
    @JvmField var data: Pointer? = null

    class ByValue : ForeignBytes(), Structure.ByValue
}
/**
 * The FfiConverter interface handles converter types to and from the FFI
 *
 * All implementing objects should be public to support external types.  When a
 * type is external we need to import it's FfiConverter.
 *
 * @suppress
 */
public interface FfiConverter<KotlinType, FfiType> {
    // Convert an FFI type to a Kotlin type
    fun lift(value: FfiType): KotlinType

    // Convert an Kotlin type to an FFI type
    fun lower(value: KotlinType): FfiType

    // Read a Kotlin type from a `ByteBuffer`
    fun read(buf: ByteBuffer): KotlinType

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    fun allocationSize(value: KotlinType): ULong

    // Write a Kotlin type to a `ByteBuffer`
    fun write(value: KotlinType, buf: ByteBuffer)

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    fun lowerIntoRustBuffer(value: KotlinType): RustBuffer.ByValue {
        val rbuf = RustBuffer.alloc(allocationSize(value))
        try {
            val bbuf = rbuf.data!!.getByteBuffer(0, rbuf.capacity).also {
                it.order(ByteOrder.BIG_ENDIAN)
            }
            write(value, bbuf)
            rbuf.writeField("len", bbuf.position().toLong())
            return rbuf
        } catch (e: Throwable) {
            RustBuffer.free(rbuf)
            throw e
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    fun liftFromRustBuffer(rbuf: RustBuffer.ByValue): KotlinType {
        val byteBuf = rbuf.asByteBuffer()!!
        try {
           val item = read(byteBuf)
           if (byteBuf.hasRemaining()) {
               throw RuntimeException("junk remaining in buffer after lifting, something is very wrong!!")
           }
           return item
        } finally {
            RustBuffer.free(rbuf)
        }
    }
}

/**
 * FfiConverter that uses `RustBuffer` as the FfiType
 *
 * @suppress
 */
public interface FfiConverterRustBuffer<KotlinType>: FfiConverter<KotlinType, RustBuffer.ByValue> {
    override fun lift(value: RustBuffer.ByValue) = liftFromRustBuffer(value)
    override fun lower(value: KotlinType) = lowerIntoRustBuffer(value)
}
// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.

internal const val UNIFFI_CALL_SUCCESS = 0.toByte()
internal const val UNIFFI_CALL_ERROR = 1.toByte()
internal const val UNIFFI_CALL_UNEXPECTED_ERROR = 2.toByte()

@Structure.FieldOrder("code", "error_buf")
internal open class UniffiRustCallStatus : Structure() {
    @JvmField var code: Byte = 0
    @JvmField var error_buf: RustBuffer.ByValue = RustBuffer.ByValue()

    class ByValue: UniffiRustCallStatus(), Structure.ByValue

    fun isSuccess(): Boolean {
        return code == UNIFFI_CALL_SUCCESS
    }

    fun isError(): Boolean {
        return code == UNIFFI_CALL_ERROR
    }

    fun isPanic(): Boolean {
        return code == UNIFFI_CALL_UNEXPECTED_ERROR
    }

    companion object {
        fun create(code: Byte, errorBuf: RustBuffer.ByValue): UniffiRustCallStatus.ByValue {
            val callStatus = UniffiRustCallStatus.ByValue()
            callStatus.code = code
            callStatus.error_buf = errorBuf
            return callStatus
        }
    }
}

class InternalException(message: String) : kotlin.Exception(message)

/**
 * Each top-level error class has a companion object that can lift the error from the call status's rust buffer
 *
 * @suppress
 */
interface UniffiRustCallStatusErrorHandler<E> {
    fun lift(error_buf: RustBuffer.ByValue): E;
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself

// Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
private inline fun <U, E: kotlin.Exception> uniffiRustCallWithError(errorHandler: UniffiRustCallStatusErrorHandler<E>, callback: (UniffiRustCallStatus) -> U): U {
    var status = UniffiRustCallStatus()
    val return_value = callback(status)
    uniffiCheckCallStatus(errorHandler, status)
    return return_value
}

// Check UniffiRustCallStatus and throw an error if the call wasn't successful
private fun<E: kotlin.Exception> uniffiCheckCallStatus(errorHandler: UniffiRustCallStatusErrorHandler<E>, status: UniffiRustCallStatus) {
    if (status.isSuccess()) {
        return
    } else if (status.isError()) {
        throw errorHandler.lift(status.error_buf)
    } else if (status.isPanic()) {
        // when the rust code sees a panic, it tries to construct a rustbuffer
        // with the message.  but if that code panics, then it just sends back
        // an empty buffer.
        if (status.error_buf.len > 0) {
            throw InternalException(FfiConverterString.lift(status.error_buf))
        } else {
            throw InternalException("Rust panic")
        }
    } else {
        throw InternalException("Unknown rust call status: $status.code")
    }
}

/**
 * UniffiRustCallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
 *
 * @suppress
 */
object UniffiNullRustCallStatusErrorHandler: UniffiRustCallStatusErrorHandler<InternalException> {
    override fun lift(error_buf: RustBuffer.ByValue): InternalException {
        RustBuffer.free(error_buf)
        return InternalException("Unexpected CALL_ERROR")
    }
}

// Call a rust function that returns a plain value
private inline fun <U> uniffiRustCall(callback: (UniffiRustCallStatus) -> U): U {
    return uniffiRustCallWithError(UniffiNullRustCallStatusErrorHandler, callback)
}

internal inline fun<T> uniffiTraitInterfaceCall(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
) {
    try {
        writeReturn(makeCall())
    } catch(e: kotlin.Exception) {
        val err = try { e.stackTraceToString() } catch(_: Throwable) { "" }
        callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
        callStatus.error_buf = FfiConverterString.lower(err)
    }
}

internal inline fun<T, reified E: Throwable> uniffiTraitInterfaceCallWithError(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
    lowerError: (E) -> RustBuffer.ByValue
) {
    try {
        writeReturn(makeCall())
    } catch(e: kotlin.Exception) {
        if (e is E) {
            callStatus.code = UNIFFI_CALL_ERROR
            callStatus.error_buf = lowerError(e)
        } else {
            val err = try { e.stackTraceToString() } catch(_: Throwable) { "" }
            callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
            callStatus.error_buf = FfiConverterString.lower(err)
        }
    }
}
// Initial value and increment amount for handles. 
// These ensure that Kotlin-generated handles always have the lowest bit set
private const val UNIFFI_HANDLEMAP_INITIAL = 1.toLong()
private const val UNIFFI_HANDLEMAP_DELTA = 2.toLong()

// Map handles to objects
//
// This is used pass an opaque 64-bit handle representing a foreign object to the Rust code.
internal class UniffiHandleMap<T: Any> {
    private val map = ConcurrentHashMap<Long, T>()
    // Start 
    private val counter = java.util.concurrent.atomic.AtomicLong(UNIFFI_HANDLEMAP_INITIAL)

    val size: Int
        get() = map.size

    // Insert a new object into the handle map and get a handle for it
    fun insert(obj: T): Long {
        val handle = counter.getAndAdd(UNIFFI_HANDLEMAP_DELTA)
        map.put(handle, obj)
        return handle
    }

    // Clone a handle, creating a new one
    fun clone(handle: Long): Long {
        val obj = map.get(handle) ?: throw InternalException("UniffiHandleMap.clone: Invalid handle")
        return insert(obj)
    }

    // Get an object from the handle map
    fun get(handle: Long): T {
        return map.get(handle) ?: throw InternalException("UniffiHandleMap.get: Invalid handle")
    }

    // Remove an entry from the handlemap and get the Kotlin object back
    fun remove(handle: Long): T {
        return map.remove(handle) ?: throw InternalException("UniffiHandleMap: Invalid handle")
    }
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.
@Synchronized
private fun findLibraryName(componentName: String): String {
    val libOverride = System.getProperty("uniffi.component.$componentName.libraryOverride")
    if (libOverride != null) {
        return libOverride
    }
    return "daybook_ffi"
}

// Define FFI callback types
internal interface UniffiRustFutureContinuationCallback : com.sun.jna.Callback {
    fun callback(`data`: Long,`pollResult`: Byte,)
}
internal interface UniffiForeignFutureDroppedCallback : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
}
internal interface UniffiCallbackInterfaceFree : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
}
internal interface UniffiCallbackInterfaceClone : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
    : Long
}
@Structure.FieldOrder("handle", "free")
internal open class UniffiForeignFutureDroppedCallbackStruct(
    @JvmField internal var `handle`: Long = 0.toLong(),
    @JvmField internal var `free`: UniffiForeignFutureDroppedCallback? = null,
) : Structure() {
    class UniffiByValue(
        `handle`: Long = 0.toLong(),
        `free`: UniffiForeignFutureDroppedCallback? = null,
    ): UniffiForeignFutureDroppedCallbackStruct(`handle`,`free`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureDroppedCallbackStruct) {
        `handle` = other.`handle`
        `free` = other.`free`
    }

}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultU8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultU8(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultU8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU8 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultU8.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultI8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultI8(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultI8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI8 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultI8.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultU16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultU16(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultU16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU16 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultU16.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultI16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultI16(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultI16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI16 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultI16.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultU32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultU32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultU32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultU32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultI32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultI32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultI32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultI32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultU64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultU64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultU64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultU64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultI64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultI64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultI64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultI64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultF32(
    @JvmField internal var `returnValue`: Float = 0.0f,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Float = 0.0f,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultF32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultF32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteF32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultF32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultF64(
    @JvmField internal var `returnValue`: Double = 0.0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Double = 0.0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultF64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultF64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteF64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultF64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultRustBuffer(
    @JvmField internal var `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultRustBuffer(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultRustBuffer) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteRustBuffer : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultRustBuffer.UniffiByValue,)
}
@Structure.FieldOrder("callStatus")
internal open class UniffiForeignFutureResultVoid(
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultVoid(`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultVoid) {
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteVoid : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultVoid.UniffiByValue,)
}
internal interface UniffiCallbackInterfaceCameraPreviewFrameListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`frame`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceConfigEventListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`event`: RustBufferConfigEvent.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceDispatchEventListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`event`: RustBufferDispatchEvent.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceDrawerEventListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`event`: RustBufferDrawerEvent.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfacePlugsEventListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`event`: RustBufferPlugsEvent.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceProgressEventListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`event`: RustBufferProgressEvent.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceTablesEventListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`event`: RustBufferTablesEvent.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
@Structure.FieldOrder("uniffiFree", "uniffiClone", "onCameraPreviewFrame")
internal open class UniffiVTableCallbackInterfaceCameraPreviewFrameListener(
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    @JvmField internal var `uniffiClone`: UniffiCallbackInterfaceClone? = null,
    @JvmField internal var `onCameraPreviewFrame`: UniffiCallbackInterfaceCameraPreviewFrameListenerMethod0? = null,
) : Structure() {
    class UniffiByValue(
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
        `uniffiClone`: UniffiCallbackInterfaceClone? = null,
        `onCameraPreviewFrame`: UniffiCallbackInterfaceCameraPreviewFrameListenerMethod0? = null,
    ): UniffiVTableCallbackInterfaceCameraPreviewFrameListener(`uniffiFree`,`uniffiClone`,`onCameraPreviewFrame`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceCameraPreviewFrameListener) {
        `uniffiFree` = other.`uniffiFree`
        `uniffiClone` = other.`uniffiClone`
        `onCameraPreviewFrame` = other.`onCameraPreviewFrame`
    }

}
@Structure.FieldOrder("uniffiFree", "uniffiClone", "onConfigEvent")
internal open class UniffiVTableCallbackInterfaceConfigEventListener(
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    @JvmField internal var `uniffiClone`: UniffiCallbackInterfaceClone? = null,
    @JvmField internal var `onConfigEvent`: UniffiCallbackInterfaceConfigEventListenerMethod0? = null,
) : Structure() {
    class UniffiByValue(
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
        `uniffiClone`: UniffiCallbackInterfaceClone? = null,
        `onConfigEvent`: UniffiCallbackInterfaceConfigEventListenerMethod0? = null,
    ): UniffiVTableCallbackInterfaceConfigEventListener(`uniffiFree`,`uniffiClone`,`onConfigEvent`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceConfigEventListener) {
        `uniffiFree` = other.`uniffiFree`
        `uniffiClone` = other.`uniffiClone`
        `onConfigEvent` = other.`onConfigEvent`
    }

}
@Structure.FieldOrder("uniffiFree", "uniffiClone", "onDispatchEvent")
internal open class UniffiVTableCallbackInterfaceDispatchEventListener(
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    @JvmField internal var `uniffiClone`: UniffiCallbackInterfaceClone? = null,
    @JvmField internal var `onDispatchEvent`: UniffiCallbackInterfaceDispatchEventListenerMethod0? = null,
) : Structure() {
    class UniffiByValue(
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
        `uniffiClone`: UniffiCallbackInterfaceClone? = null,
        `onDispatchEvent`: UniffiCallbackInterfaceDispatchEventListenerMethod0? = null,
    ): UniffiVTableCallbackInterfaceDispatchEventListener(`uniffiFree`,`uniffiClone`,`onDispatchEvent`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceDispatchEventListener) {
        `uniffiFree` = other.`uniffiFree`
        `uniffiClone` = other.`uniffiClone`
        `onDispatchEvent` = other.`onDispatchEvent`
    }

}
@Structure.FieldOrder("uniffiFree", "uniffiClone", "onDrawerEvent")
internal open class UniffiVTableCallbackInterfaceDrawerEventListener(
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    @JvmField internal var `uniffiClone`: UniffiCallbackInterfaceClone? = null,
    @JvmField internal var `onDrawerEvent`: UniffiCallbackInterfaceDrawerEventListenerMethod0? = null,
) : Structure() {
    class UniffiByValue(
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
        `uniffiClone`: UniffiCallbackInterfaceClone? = null,
        `onDrawerEvent`: UniffiCallbackInterfaceDrawerEventListenerMethod0? = null,
    ): UniffiVTableCallbackInterfaceDrawerEventListener(`uniffiFree`,`uniffiClone`,`onDrawerEvent`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceDrawerEventListener) {
        `uniffiFree` = other.`uniffiFree`
        `uniffiClone` = other.`uniffiClone`
        `onDrawerEvent` = other.`onDrawerEvent`
    }

}
@Structure.FieldOrder("uniffiFree", "uniffiClone", "onPlugsEvent")
internal open class UniffiVTableCallbackInterfacePlugsEventListener(
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    @JvmField internal var `uniffiClone`: UniffiCallbackInterfaceClone? = null,
    @JvmField internal var `onPlugsEvent`: UniffiCallbackInterfacePlugsEventListenerMethod0? = null,
) : Structure() {
    class UniffiByValue(
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
        `uniffiClone`: UniffiCallbackInterfaceClone? = null,
        `onPlugsEvent`: UniffiCallbackInterfacePlugsEventListenerMethod0? = null,
    ): UniffiVTableCallbackInterfacePlugsEventListener(`uniffiFree`,`uniffiClone`,`onPlugsEvent`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfacePlugsEventListener) {
        `uniffiFree` = other.`uniffiFree`
        `uniffiClone` = other.`uniffiClone`
        `onPlugsEvent` = other.`onPlugsEvent`
    }

}
@Structure.FieldOrder("uniffiFree", "uniffiClone", "onProgressEvent")
internal open class UniffiVTableCallbackInterfaceProgressEventListener(
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    @JvmField internal var `uniffiClone`: UniffiCallbackInterfaceClone? = null,
    @JvmField internal var `onProgressEvent`: UniffiCallbackInterfaceProgressEventListenerMethod0? = null,
) : Structure() {
    class UniffiByValue(
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
        `uniffiClone`: UniffiCallbackInterfaceClone? = null,
        `onProgressEvent`: UniffiCallbackInterfaceProgressEventListenerMethod0? = null,
    ): UniffiVTableCallbackInterfaceProgressEventListener(`uniffiFree`,`uniffiClone`,`onProgressEvent`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceProgressEventListener) {
        `uniffiFree` = other.`uniffiFree`
        `uniffiClone` = other.`uniffiClone`
        `onProgressEvent` = other.`onProgressEvent`
    }

}
@Structure.FieldOrder("uniffiFree", "uniffiClone", "onTablesEvent")
internal open class UniffiVTableCallbackInterfaceTablesEventListener(
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    @JvmField internal var `uniffiClone`: UniffiCallbackInterfaceClone? = null,
    @JvmField internal var `onTablesEvent`: UniffiCallbackInterfaceTablesEventListenerMethod0? = null,
) : Structure() {
    class UniffiByValue(
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
        `uniffiClone`: UniffiCallbackInterfaceClone? = null,
        `onTablesEvent`: UniffiCallbackInterfaceTablesEventListenerMethod0? = null,
    ): UniffiVTableCallbackInterfaceTablesEventListener(`uniffiFree`,`uniffiClone`,`onTablesEvent`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceTablesEventListener) {
        `uniffiFree` = other.`uniffiFree`
        `uniffiClone` = other.`uniffiClone`
        `onTablesEvent` = other.`onTablesEvent`
    }

}

// A JNA Library to expose the extern-C FFI definitions.
// This is an implementation detail which will be called internally by the public API.

// For large crates we prevent `MethodTooLargeException` (see #2340)
// N.B. the name of the extension is very misleading, since it is
// rather `InterfaceTooLargeException`, caused by too many methods
// in the interface for large crates.
//
// By splitting the otherwise huge interface into two parts
// * UniffiLib (this)
// * IntegrityCheckingUniffiLib
// And all checksum methods are put into `IntegrityCheckingUniffiLib`
// we allow for ~2x as many methods in the UniffiLib interface.
//
// Note: above all written when we used JNA's `loadIndirect` etc.
// We now use JNA's "direct mapping" - unclear if same considerations apply exactly.
internal object IntegrityCheckingUniffiLib {
    init {
        Native.register(IntegrityCheckingUniffiLib::class.java, findLibraryName(componentName = "daybook_ffi"))
        uniffiCheckContractApiVersion(this)
        uniffiCheckApiChecksums(this)
    }
    external fun uniffi_daybook_ffi_checksum_method_camerapreviewffi_latest_frame(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_camerapreviewffi_list_devices(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_camerapreviewffi_start_stream(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_camerapreviewffi_stop_stream(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_camerapreviewffi_take_latest_frame(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_camerapreviewframelistener_on_camera_preview_frame(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_ffictx_get_last_used_repo(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_ffictx_is_repo_usable(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_ffictx_list_known_repos(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_ffictx_register_repo_path(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_ffierror_message(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_blobsrepoffi_get_path(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_blobsrepoffi_put(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_configeventlistener_on_config_event(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_configrepoffi_ffi_register_listener(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_configrepoffi_get_facet_display_hint(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_configrepoffi_list_display_hints(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_configrepoffi_set_facet_display_hint(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_configrepoffi_stop(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_dispatcheventlistener_on_dispatch_event(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_dispatchrepoffi_ffi_register_listener(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_dispatchrepoffi_list(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_dispatchrepoffi_stop(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_drawereventlistener_on_drawer_event(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_drawerrepoffi_add(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_drawerrepoffi_del(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_drawerrepoffi_ffi_register_listener(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_drawerrepoffi_get(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_drawerrepoffi_list(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_drawerrepoffi_stop(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_drawerrepoffi_update(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_drawerrepoffi_update_batch(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_plugseventlistener_on_plugs_event(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_plugsrepoffi_ffi_register_listener(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_plugsrepoffi_stop(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_progresseventlistener_on_progress_event(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_progressrepoffi_clear_completed(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_progressrepoffi_dismiss(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_progressrepoffi_ffi_add_update(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_progressrepoffi_ffi_register_listener(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_progressrepoffi_ffi_upsert_task(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_progressrepoffi_get(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_progressrepoffi_list(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_progressrepoffi_list_by_tag_prefix(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_progressrepoffi_list_updates(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_progressrepoffi_mark_viewed(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_progressrepoffi_set_retention_override(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_tableseventlistener_on_tables_event(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_tablesrepoffi_create_new_tab(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_tablesrepoffi_create_new_table(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_tablesrepoffi_ffi_register_listener(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_tablesrepoffi_get_panel(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_tablesrepoffi_get_selected_table(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_tablesrepoffi_get_tab(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_tablesrepoffi_get_table(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_tablesrepoffi_get_window(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_tablesrepoffi_list_panels(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_tablesrepoffi_list_tables(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_tablesrepoffi_list_tabs(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_tablesrepoffi_list_windows(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_tablesrepoffi_remove_tab(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_tablesrepoffi_set_panel(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_tablesrepoffi_set_tab(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_tablesrepoffi_set_table(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_tablesrepoffi_set_window(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_tablesrepoffi_stop(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_tablesrepoffi_update_batch(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_rtffi_dispatch_doc_facet(
    ): Short
    external fun uniffi_daybook_ffi_checksum_method_rtffi_stop(
    ): Short
    external fun uniffi_daybook_ffi_checksum_constructor_camerapreviewffi_load(
    ): Short
    external fun uniffi_daybook_ffi_checksum_constructor_ffictx_for_ffi(
    ): Short
    external fun uniffi_daybook_ffi_checksum_constructor_ffictx_for_globals(
    ): Short
    external fun uniffi_daybook_ffi_checksum_constructor_ffictx_for_repo_root(
    ): Short
    external fun uniffi_daybook_ffi_checksum_constructor_blobsrepoffi_load(
    ): Short
    external fun uniffi_daybook_ffi_checksum_constructor_configrepoffi_load(
    ): Short
    external fun uniffi_daybook_ffi_checksum_constructor_dispatchrepoffi_load(
    ): Short
    external fun uniffi_daybook_ffi_checksum_constructor_drawerrepoffi_load(
    ): Short
    external fun uniffi_daybook_ffi_checksum_constructor_plugsrepoffi_load(
    ): Short
    external fun uniffi_daybook_ffi_checksum_constructor_progressrepoffi_load(
    ): Short
    external fun uniffi_daybook_ffi_checksum_constructor_tablesrepoffi_load(
    ): Short
    external fun uniffi_daybook_ffi_checksum_constructor_rtffi_load(
    ): Short
    external fun ffi_daybook_ffi_uniffi_contract_version(
    ): Int

        
}

internal object UniffiLib {
    
    // The Cleaner for the whole library
    internal val CLEANER: UniffiCleaner by lazy {
        UniffiCleaner.create()
    }
    

    init {
        Native.register(UniffiLib::class.java, findLibraryName(componentName = "daybook_ffi"))
        uniffiCallbackInterfaceCameraPreviewFrameListener.register(this)
        uniffiCallbackInterfaceConfigEventListener.register(this)
        uniffiCallbackInterfaceDispatchEventListener.register(this)
        uniffiCallbackInterfaceDrawerEventListener.register(this)
        uniffiCallbackInterfacePlugsEventListener.register(this)
        uniffiCallbackInterfaceProgressEventListener.register(this)
        uniffiCallbackInterfaceTablesEventListener.register(this)
        org.example.daybook.uniffi.core.uniffiEnsureInitialized()
        org.example.daybook.uniffi.types.uniffiEnsureInitialized()
        
    }
    external fun uniffi_daybook_ffi_fn_clone_camerapreviewffi(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_daybook_ffi_fn_free_camerapreviewffi(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_constructor_camerapreviewffi_load(uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_daybook_ffi_fn_method_camerapreviewffi_latest_frame(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_daybook_ffi_fn_method_camerapreviewffi_list_devices(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_daybook_ffi_fn_method_camerapreviewffi_start_stream(`ptr`: Long,`deviceId`: Int,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_method_camerapreviewffi_stop_stream(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_method_camerapreviewffi_take_latest_frame(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_daybook_ffi_fn_clone_camerapreviewframelistener(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_daybook_ffi_fn_free_camerapreviewframelistener(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_init_callback_vtable_camerapreviewframelistener(`vtable`: UniffiVTableCallbackInterfaceCameraPreviewFrameListener,
): Unit
external fun uniffi_daybook_ffi_fn_method_camerapreviewframelistener_on_camera_preview_frame(`ptr`: Long,`frame`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_clone_ffictx(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_daybook_ffi_fn_free_ffictx(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_constructor_ffictx_for_ffi(
): Long
external fun uniffi_daybook_ffi_fn_constructor_ffictx_for_globals(
): Long
external fun uniffi_daybook_ffi_fn_constructor_ffictx_for_repo_root(`repoRoot`: RustBuffer.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_ffictx_get_last_used_repo(`ptr`: Long,
): Long
external fun uniffi_daybook_ffi_fn_method_ffictx_is_repo_usable(`ptr`: Long,`repoRoot`: RustBuffer.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_ffictx_list_known_repos(`ptr`: Long,
): Long
external fun uniffi_daybook_ffi_fn_method_ffictx_register_repo_path(`ptr`: Long,`repoRoot`: RustBuffer.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_clone_ffierror(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_daybook_ffi_fn_free_ffierror(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_method_ffierror_message(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_daybook_ffi_fn_clone_blobsrepoffi(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_daybook_ffi_fn_free_blobsrepoffi(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_constructor_blobsrepoffi_load(`fcx`: Long,
): Long
external fun uniffi_daybook_ffi_fn_method_blobsrepoffi_get_path(`ptr`: Long,`hash`: RustBuffer.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_blobsrepoffi_put(`ptr`: Long,`data`: RustBuffer.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_clone_configeventlistener(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_daybook_ffi_fn_free_configeventlistener(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_init_callback_vtable_configeventlistener(`vtable`: UniffiVTableCallbackInterfaceConfigEventListener,
): Unit
external fun uniffi_daybook_ffi_fn_method_configeventlistener_on_config_event(`ptr`: Long,`event`: RustBufferConfigEvent.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_clone_configrepoffi(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_daybook_ffi_fn_free_configrepoffi(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_constructor_configrepoffi_load(`fcx`: Long,`plugRepo`: Long,
): Long
external fun uniffi_daybook_ffi_fn_method_configrepoffi_ffi_register_listener(`ptr`: Long,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_daybook_ffi_fn_method_configrepoffi_get_facet_display_hint(`ptr`: Long,`id`: RustBuffer.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_configrepoffi_list_display_hints(`ptr`: Long,
): Long
external fun uniffi_daybook_ffi_fn_method_configrepoffi_set_facet_display_hint(`ptr`: Long,`key`: RustBuffer.ByValue,`config`: RustBufferFacetDisplayHint.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_configrepoffi_stop(`ptr`: Long,
): Long
external fun uniffi_daybook_ffi_fn_clone_dispatcheventlistener(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_daybook_ffi_fn_free_dispatcheventlistener(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_init_callback_vtable_dispatcheventlistener(`vtable`: UniffiVTableCallbackInterfaceDispatchEventListener,
): Unit
external fun uniffi_daybook_ffi_fn_method_dispatcheventlistener_on_dispatch_event(`ptr`: Long,`event`: RustBufferDispatchEvent.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_clone_dispatchrepoffi(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_daybook_ffi_fn_free_dispatchrepoffi(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_constructor_dispatchrepoffi_load(`fcx`: Long,
): Long
external fun uniffi_daybook_ffi_fn_method_dispatchrepoffi_ffi_register_listener(`ptr`: Long,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_daybook_ffi_fn_method_dispatchrepoffi_list(`ptr`: Long,
): Long
external fun uniffi_daybook_ffi_fn_method_dispatchrepoffi_stop(`ptr`: Long,
): Long
external fun uniffi_daybook_ffi_fn_clone_drawereventlistener(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_daybook_ffi_fn_free_drawereventlistener(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_init_callback_vtable_drawereventlistener(`vtable`: UniffiVTableCallbackInterfaceDrawerEventListener,
): Unit
external fun uniffi_daybook_ffi_fn_method_drawereventlistener_on_drawer_event(`ptr`: Long,`event`: RustBufferDrawerEvent.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_clone_drawerrepoffi(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_daybook_ffi_fn_free_drawerrepoffi(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_constructor_drawerrepoffi_load(`fcx`: Long,`plugsRepo`: Long,
): Long
external fun uniffi_daybook_ffi_fn_method_drawerrepoffi_add(`ptr`: Long,`args`: RustBufferAddDocArgs.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_drawerrepoffi_del(`ptr`: Long,`id`: RustBuffer.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_drawerrepoffi_ffi_register_listener(`ptr`: Long,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_daybook_ffi_fn_method_drawerrepoffi_get(`ptr`: Long,`id`: RustBuffer.ByValue,`branchPath`: RustBuffer.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_drawerrepoffi_list(`ptr`: Long,
): Long
external fun uniffi_daybook_ffi_fn_method_drawerrepoffi_stop(`ptr`: Long,
): Long
external fun uniffi_daybook_ffi_fn_method_drawerrepoffi_update(`ptr`: Long,`patch`: RustBufferDocPatch.ByValue,`branchPath`: RustBuffer.ByValue,`heads`: RustBuffer.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_drawerrepoffi_update_batch(`ptr`: Long,`patches`: RustBuffer.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_clone_plugseventlistener(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_daybook_ffi_fn_free_plugseventlistener(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_init_callback_vtable_plugseventlistener(`vtable`: UniffiVTableCallbackInterfacePlugsEventListener,
): Unit
external fun uniffi_daybook_ffi_fn_method_plugseventlistener_on_plugs_event(`ptr`: Long,`event`: RustBufferPlugsEvent.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_clone_plugsrepoffi(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_daybook_ffi_fn_free_plugsrepoffi(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_constructor_plugsrepoffi_load(`fcx`: Long,`blobsRepo`: Long,
): Long
external fun uniffi_daybook_ffi_fn_method_plugsrepoffi_ffi_register_listener(`ptr`: Long,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_daybook_ffi_fn_method_plugsrepoffi_stop(`ptr`: Long,
): Long
external fun uniffi_daybook_ffi_fn_clone_progresseventlistener(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_daybook_ffi_fn_free_progresseventlistener(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_init_callback_vtable_progresseventlistener(`vtable`: UniffiVTableCallbackInterfaceProgressEventListener,
): Unit
external fun uniffi_daybook_ffi_fn_method_progresseventlistener_on_progress_event(`ptr`: Long,`event`: RustBufferProgressEvent.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_clone_progressrepoffi(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_daybook_ffi_fn_free_progressrepoffi(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_constructor_progressrepoffi_load(`fcx`: Long,
): Long
external fun uniffi_daybook_ffi_fn_method_progressrepoffi_clear_completed(`ptr`: Long,
): Long
external fun uniffi_daybook_ffi_fn_method_progressrepoffi_dismiss(`ptr`: Long,`id`: RustBuffer.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_progressrepoffi_ffi_add_update(`ptr`: Long,`id`: RustBuffer.ByValue,`update`: RustBufferProgressUpdate.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_progressrepoffi_ffi_register_listener(`ptr`: Long,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_daybook_ffi_fn_method_progressrepoffi_ffi_upsert_task(`ptr`: Long,`args`: RustBufferCreateProgressTaskArgs.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_progressrepoffi_get(`ptr`: Long,`id`: RustBuffer.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_progressrepoffi_list(`ptr`: Long,
): Long
external fun uniffi_daybook_ffi_fn_method_progressrepoffi_list_by_tag_prefix(`ptr`: Long,`tagPrefix`: RustBuffer.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_progressrepoffi_list_updates(`ptr`: Long,`id`: RustBuffer.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_progressrepoffi_mark_viewed(`ptr`: Long,`id`: RustBuffer.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_progressrepoffi_set_retention_override(`ptr`: Long,`id`: RustBuffer.ByValue,`retention`: RustBuffer.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_clone_tableseventlistener(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_daybook_ffi_fn_free_tableseventlistener(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_init_callback_vtable_tableseventlistener(`vtable`: UniffiVTableCallbackInterfaceTablesEventListener,
): Unit
external fun uniffi_daybook_ffi_fn_method_tableseventlistener_on_tables_event(`ptr`: Long,`event`: RustBufferTablesEvent.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_clone_tablesrepoffi(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_daybook_ffi_fn_free_tablesrepoffi(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_constructor_tablesrepoffi_load(`fcx`: Long,
): Long
external fun uniffi_daybook_ffi_fn_method_tablesrepoffi_create_new_tab(`ptr`: Long,`tableId`: RustBuffer.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_tablesrepoffi_create_new_table(`ptr`: Long,
): Long
external fun uniffi_daybook_ffi_fn_method_tablesrepoffi_ffi_register_listener(`ptr`: Long,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_daybook_ffi_fn_method_tablesrepoffi_get_panel(`ptr`: Long,`id`: RustBuffer.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_tablesrepoffi_get_selected_table(`ptr`: Long,
): Long
external fun uniffi_daybook_ffi_fn_method_tablesrepoffi_get_tab(`ptr`: Long,`id`: RustBuffer.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_tablesrepoffi_get_table(`ptr`: Long,`id`: RustBuffer.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_tablesrepoffi_get_window(`ptr`: Long,`id`: RustBuffer.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_tablesrepoffi_list_panels(`ptr`: Long,
): Long
external fun uniffi_daybook_ffi_fn_method_tablesrepoffi_list_tables(`ptr`: Long,
): Long
external fun uniffi_daybook_ffi_fn_method_tablesrepoffi_list_tabs(`ptr`: Long,
): Long
external fun uniffi_daybook_ffi_fn_method_tablesrepoffi_list_windows(`ptr`: Long,
): Long
external fun uniffi_daybook_ffi_fn_method_tablesrepoffi_remove_tab(`ptr`: Long,`tabId`: RustBuffer.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_tablesrepoffi_set_panel(`ptr`: Long,`id`: RustBuffer.ByValue,`panel`: RustBufferPanel.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_tablesrepoffi_set_tab(`ptr`: Long,`id`: RustBuffer.ByValue,`tab`: RustBufferTab.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_tablesrepoffi_set_table(`ptr`: Long,`id`: RustBuffer.ByValue,`table`: RustBufferTable.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_tablesrepoffi_set_window(`ptr`: Long,`id`: RustBuffer.ByValue,`window`: RustBufferWindow.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_tablesrepoffi_stop(`ptr`: Long,
): Long
external fun uniffi_daybook_ffi_fn_method_tablesrepoffi_update_batch(`ptr`: Long,`patches`: RustBufferTablesPatches.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_clone_rtffi(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_daybook_ffi_fn_free_rtffi(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_daybook_ffi_fn_constructor_rtffi_load(`fcx`: Long,`drawerRepo`: Long,`plugsRepo`: Long,`dispatchRepo`: Long,`progressRepo`: Long,`blobsRepo`: Long,`configRepo`: Long,`deviceId`: RustBuffer.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_rtffi_dispatch_doc_facet(`ptr`: Long,`plugId`: RustBuffer.ByValue,`routineName`: RustBuffer.ByValue,`docId`: RustBuffer.ByValue,`branchPath`: RustBuffer.ByValue,
): Long
external fun uniffi_daybook_ffi_fn_method_rtffi_stop(`ptr`: Long,
): Long
external fun ffi_daybook_ffi_rustbuffer_alloc(`size`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun ffi_daybook_ffi_rustbuffer_from_bytes(`bytes`: ForeignBytes.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun ffi_daybook_ffi_rustbuffer_free(`buf`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun ffi_daybook_ffi_rustbuffer_reserve(`buf`: RustBuffer.ByValue,`additional`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun ffi_daybook_ffi_rust_future_poll_u8(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_cancel_u8(`handle`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_free_u8(`handle`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_complete_u8(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
external fun ffi_daybook_ffi_rust_future_poll_i8(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_cancel_i8(`handle`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_free_i8(`handle`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_complete_i8(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
external fun ffi_daybook_ffi_rust_future_poll_u16(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_cancel_u16(`handle`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_free_u16(`handle`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_complete_u16(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Short
external fun ffi_daybook_ffi_rust_future_poll_i16(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_cancel_i16(`handle`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_free_i16(`handle`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_complete_i16(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Short
external fun ffi_daybook_ffi_rust_future_poll_u32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_cancel_u32(`handle`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_free_u32(`handle`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_complete_u32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
external fun ffi_daybook_ffi_rust_future_poll_i32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_cancel_i32(`handle`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_free_i32(`handle`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_complete_i32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
external fun ffi_daybook_ffi_rust_future_poll_u64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_cancel_u64(`handle`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_free_u64(`handle`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_complete_u64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun ffi_daybook_ffi_rust_future_poll_i64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_cancel_i64(`handle`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_free_i64(`handle`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_complete_i64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun ffi_daybook_ffi_rust_future_poll_f32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_cancel_f32(`handle`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_free_f32(`handle`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_complete_f32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Float
external fun ffi_daybook_ffi_rust_future_poll_f64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_cancel_f64(`handle`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_free_f64(`handle`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_complete_f64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Double
external fun ffi_daybook_ffi_rust_future_poll_rust_buffer(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_cancel_rust_buffer(`handle`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_free_rust_buffer(`handle`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_complete_rust_buffer(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun ffi_daybook_ffi_rust_future_poll_void(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_cancel_void(`handle`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_free_void(`handle`: Long,
): Unit
external fun ffi_daybook_ffi_rust_future_complete_void(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit

    
}

private fun uniffiCheckContractApiVersion(lib: IntegrityCheckingUniffiLib) {
    // Get the bindings contract version from our ComponentInterface
    val bindings_contract_version = 30
    // Get the scaffolding contract version by calling the into the dylib
    val scaffolding_contract_version = lib.ffi_daybook_ffi_uniffi_contract_version()
    if (bindings_contract_version != scaffolding_contract_version) {
        throw RuntimeException("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    }
}
@Suppress("UNUSED_PARAMETER")
private fun uniffiCheckApiChecksums(lib: IntegrityCheckingUniffiLib) {
    if (lib.uniffi_daybook_ffi_checksum_method_camerapreviewffi_latest_frame() != 62738.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_camerapreviewffi_list_devices() != 49134.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_camerapreviewffi_start_stream() != 54772.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_camerapreviewffi_stop_stream() != 38889.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_camerapreviewffi_take_latest_frame() != 63251.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_camerapreviewframelistener_on_camera_preview_frame() != 54052.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_ffictx_get_last_used_repo() != 35423.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_ffictx_is_repo_usable() != 15091.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_ffictx_list_known_repos() != 60784.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_ffictx_register_repo_path() != 14592.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_ffierror_message() != 61441.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_blobsrepoffi_get_path() != 43520.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_blobsrepoffi_put() != 12349.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_configeventlistener_on_config_event() != 2763.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_configrepoffi_ffi_register_listener() != 12494.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_configrepoffi_get_facet_display_hint() != 14702.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_configrepoffi_list_display_hints() != 47455.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_configrepoffi_set_facet_display_hint() != 7725.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_configrepoffi_stop() != 42921.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_dispatcheventlistener_on_dispatch_event() != 5326.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_dispatchrepoffi_ffi_register_listener() != 57721.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_dispatchrepoffi_list() != 38781.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_dispatchrepoffi_stop() != 34345.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_drawereventlistener_on_drawer_event() != 33569.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_drawerrepoffi_add() != 51475.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_drawerrepoffi_del() != 52435.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_drawerrepoffi_ffi_register_listener() != 35670.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_drawerrepoffi_get() != 37722.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_drawerrepoffi_list() != 44053.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_drawerrepoffi_stop() != 30008.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_drawerrepoffi_update() != 55647.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_drawerrepoffi_update_batch() != 32707.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_plugseventlistener_on_plugs_event() != 23122.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_plugsrepoffi_ffi_register_listener() != 42144.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_plugsrepoffi_stop() != 16868.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_progresseventlistener_on_progress_event() != 13451.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_progressrepoffi_clear_completed() != 12325.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_progressrepoffi_dismiss() != 13023.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_progressrepoffi_ffi_add_update() != 26002.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_progressrepoffi_ffi_register_listener() != 41661.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_progressrepoffi_ffi_upsert_task() != 24380.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_progressrepoffi_get() != 19936.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_progressrepoffi_list() != 40222.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_progressrepoffi_list_by_tag_prefix() != 32341.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_progressrepoffi_list_updates() != 10270.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_progressrepoffi_mark_viewed() != 64573.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_progressrepoffi_set_retention_override() != 36164.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_tableseventlistener_on_tables_event() != 16910.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_tablesrepoffi_create_new_tab() != 54906.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_tablesrepoffi_create_new_table() != 53194.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_tablesrepoffi_ffi_register_listener() != 16706.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_tablesrepoffi_get_panel() != 24234.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_tablesrepoffi_get_selected_table() != 14569.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_tablesrepoffi_get_tab() != 50172.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_tablesrepoffi_get_table() != 8956.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_tablesrepoffi_get_window() != 14781.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_tablesrepoffi_list_panels() != 44115.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_tablesrepoffi_list_tables() != 55374.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_tablesrepoffi_list_tabs() != 8846.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_tablesrepoffi_list_windows() != 16706.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_tablesrepoffi_remove_tab() != 36124.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_tablesrepoffi_set_panel() != 42245.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_tablesrepoffi_set_tab() != 27428.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_tablesrepoffi_set_table() != 44601.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_tablesrepoffi_set_window() != 29468.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_tablesrepoffi_stop() != 37116.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_tablesrepoffi_update_batch() != 6945.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_rtffi_dispatch_doc_facet() != 39849.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_method_rtffi_stop() != 24290.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_constructor_camerapreviewffi_load() != 30437.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_constructor_ffictx_for_ffi() != 34021.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_constructor_ffictx_for_globals() != 37051.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_constructor_ffictx_for_repo_root() != 37091.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_constructor_blobsrepoffi_load() != 24145.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_constructor_configrepoffi_load() != 11344.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_constructor_dispatchrepoffi_load() != 17588.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_constructor_drawerrepoffi_load() != 49207.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_constructor_plugsrepoffi_load() != 22500.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_constructor_progressrepoffi_load() != 4008.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_constructor_tablesrepoffi_load() != 40277.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_daybook_ffi_checksum_constructor_rtffi_load() != 49748.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

/**
 * @suppress
 */
public fun uniffiEnsureInitialized() {
    IntegrityCheckingUniffiLib
    // UniffiLib() initialized as objects are used, but we still need to explicitly
    // reference it so initialization across crates works as expected.
    UniffiLib
}

// Async support
// Async return type handlers

internal const val UNIFFI_RUST_FUTURE_POLL_READY = 0.toByte()
internal const val UNIFFI_RUST_FUTURE_POLL_WAKE = 1.toByte()

internal val uniffiContinuationHandleMap = UniffiHandleMap<CancellableContinuation<Byte>>()

// FFI type for Rust future continuations
internal object uniffiRustFutureContinuationCallbackImpl: UniffiRustFutureContinuationCallback {
    override fun callback(data: Long, pollResult: Byte) {
        uniffiContinuationHandleMap.remove(data).resume(pollResult)
    }
}

internal suspend fun<T, F, E: kotlin.Exception> uniffiRustCallAsync(
    rustFuture: Long,
    pollFunc: (Long, UniffiRustFutureContinuationCallback, Long) -> Unit,
    completeFunc: (Long, UniffiRustCallStatus) -> F,
    freeFunc: (Long) -> Unit,
    liftFunc: (F) -> T,
    errorHandler: UniffiRustCallStatusErrorHandler<E>
): T {
    try {
        do {
            val pollResult = suspendCancellableCoroutine<Byte> { continuation ->
                pollFunc(
                    rustFuture,
                    uniffiRustFutureContinuationCallbackImpl,
                    uniffiContinuationHandleMap.insert(continuation)
                )
            }
        } while (pollResult != UNIFFI_RUST_FUTURE_POLL_READY);

        return liftFunc(
            uniffiRustCallWithError(errorHandler, { status -> completeFunc(rustFuture, status) })
        )
    } finally {
        freeFunc(rustFuture)
    }
}

// Public interface members begin here.


// Interface implemented by anything that can contain an object reference.
//
// Such types expose a `destroy()` method that must be called to cleanly
// dispose of the contained objects. Failure to call this method may result
// in memory leaks.
//
// The easiest way to ensure this method is called is to use the `.use`
// helper method to execute a block and destroy the object at the end.
interface Disposable {
    fun destroy()
    companion object {
        fun destroy(vararg args: Any?) {
            for (arg in args) {
                when (arg) {
                    is Disposable -> arg.destroy()
                    is ArrayList<*> -> {
                        for (idx in arg.indices) {
                            val element = arg[idx]
                            if (element is Disposable) {
                                element.destroy()
                            }
                        }
                    }
                    is Map<*, *> -> {
                        for (element in arg.values) {
                            if (element is Disposable) {
                                element.destroy()
                            }
                        }
                    }
                    is Iterable<*> -> {
                        for (element in arg) {
                            if (element is Disposable) {
                                element.destroy()
                            }
                        }
                    }
                }
            }
        }
    }
}

/**
 * @suppress
 */
inline fun <T : Disposable?, R> T.use(block: (T) -> R) =
    try {
        block(this)
    } finally {
        try {
            // N.B. our implementation is on the nullable type `Disposable?`.
            this?.destroy()
        } catch (e: Throwable) {
            // swallow
        }
    }

/** 
 * Placeholder object used to signal that we're constructing an interface with a FFI handle.
 *
 * This is the first argument for interface constructors that input a raw handle. It exists is that
 * so we can avoid signature conflicts when an interface has a regular constructor than inputs a
 * Long.
 *
 * @suppress
 * */
object UniffiWithHandle

/** 
 * Used to instantiate an interface without an actual pointer, for fakes in tests, mostly.
 *
 * @suppress
 * */
object NoHandle// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
internal const val IDX_CALLBACK_FREE = 0
// Callback return codes
internal const val UNIFFI_CALLBACK_SUCCESS = 0
internal const val UNIFFI_CALLBACK_ERROR = 1
internal const val UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

/**
 * @suppress
 */
public abstract class FfiConverterCallbackInterface<CallbackInterface: Any>: FfiConverter<CallbackInterface, Long> {
    internal val handleMap = UniffiHandleMap<CallbackInterface>()

    internal fun drop(handle: Long) {
        handleMap.remove(handle)
    }

    override fun lift(value: Long): CallbackInterface {
        return handleMap.get(value)
    }

    override fun read(buf: ByteBuffer) = lift(buf.getLong())

    override fun lower(value: CallbackInterface) = handleMap.insert(value)

    override fun allocationSize(value: CallbackInterface) = 8UL

    override fun write(value: CallbackInterface, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}
/**
 * The cleaner interface for Object finalization code to run.
 * This is the entry point to any implementation that we're using.
 *
 * The cleaner registers objects and returns cleanables, so now we are
 * defining a `UniffiCleaner` with a `UniffiClenaer.Cleanable` to abstract the
 * different implmentations available at compile time.
 *
 * @suppress
 */
interface UniffiCleaner {
    interface Cleanable {
        fun clean()
    }

    fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable

    companion object
}

// The fallback Jna cleaner, which is available for both Android, and the JVM.
private class UniffiJnaCleaner : UniffiCleaner {
    private val cleaner = com.sun.jna.internal.Cleaner.getCleaner()

    override fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable =
        UniffiJnaCleanable(cleaner.register(value, cleanUpTask))
}

private class UniffiJnaCleanable(
    private val cleanable: com.sun.jna.internal.Cleaner.Cleanable,
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}


// We decide at uniffi binding generation time whether we were
// using Android or not.
// There are further runtime checks to chose the correct implementation
// of the cleaner.
private fun UniffiCleaner.Companion.create(): UniffiCleaner =
    try {
        // For safety's sake: if the library hasn't been run in android_cleaner = true
        // mode, but is being run on Android, then we still need to think about
        // Android API versions.
        // So we check if java.lang.ref.Cleaner is there, and use that
        java.lang.Class.forName("java.lang.ref.Cleaner")
        JavaLangRefCleaner()
    } catch (e: ClassNotFoundException) {
        //  otherwise, fallback to the JNA cleaner.
        UniffiJnaCleaner()
    }

private class JavaLangRefCleaner : UniffiCleaner {
    val cleaner = java.lang.ref.Cleaner.create()

    override fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable =
        JavaLangRefCleanable(cleaner.register(value, cleanUpTask))
}

private class JavaLangRefCleanable(
    val cleanable: java.lang.ref.Cleaner.Cleanable
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}

/**
 * @suppress
 */
public object FfiConverterUInt: FfiConverter<UInt, Int> {
    override fun lift(value: Int): UInt {
        return value.toUInt()
    }

    override fun read(buf: ByteBuffer): UInt {
        return lift(buf.getInt())
    }

    override fun lower(value: UInt): Int {
        return value.toInt()
    }

    override fun allocationSize(value: UInt) = 4UL

    override fun write(value: UInt, buf: ByteBuffer) {
        buf.putInt(value.toInt())
    }
}

/**
 * @suppress
 */
public object FfiConverterULong: FfiConverter<ULong, Long> {
    override fun lift(value: Long): ULong {
        return value.toULong()
    }

    override fun read(buf: ByteBuffer): ULong {
        return lift(buf.getLong())
    }

    override fun lower(value: ULong): Long {
        return value.toLong()
    }

    override fun allocationSize(value: ULong) = 8UL

    override fun write(value: ULong, buf: ByteBuffer) {
        buf.putLong(value.toLong())
    }
}

/**
 * @suppress
 */
public object FfiConverterLong: FfiConverter<Long, Long> {
    override fun lift(value: Long): Long {
        return value
    }

    override fun read(buf: ByteBuffer): Long {
        return buf.getLong()
    }

    override fun lower(value: Long): Long {
        return value
    }

    override fun allocationSize(value: Long) = 8UL

    override fun write(value: Long, buf: ByteBuffer) {
        buf.putLong(value)
    }
}

/**
 * @suppress
 */
public object FfiConverterBoolean: FfiConverter<Boolean, Byte> {
    override fun lift(value: Byte): Boolean {
        return value.toInt() != 0
    }

    override fun read(buf: ByteBuffer): Boolean {
        return lift(buf.get())
    }

    override fun lower(value: Boolean): Byte {
        return if (value) 1.toByte() else 0.toByte()
    }

    override fun allocationSize(value: Boolean) = 1UL

    override fun write(value: Boolean, buf: ByteBuffer) {
        buf.put(lower(value))
    }
}

/**
 * @suppress
 */
public object FfiConverterString: FfiConverter<String, RustBuffer.ByValue> {
    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    override fun lift(value: RustBuffer.ByValue): String {
        try {
            val byteArr = ByteArray(value.len.toInt())
            value.asByteBuffer()!!.get(byteArr)
            return byteArr.toString(Charsets.UTF_8)
        } finally {
            RustBuffer.free(value)
        }
    }

    override fun read(buf: ByteBuffer): String {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr.toString(Charsets.UTF_8)
    }

    fun toUtf8(value: String): ByteBuffer {
        // Make sure we don't have invalid UTF-16, check for lone surrogates.
        return Charsets.UTF_8.newEncoder().run {
            onMalformedInput(CodingErrorAction.REPORT)
            encode(CharBuffer.wrap(value))
        }
    }

    override fun lower(value: String): RustBuffer.ByValue {
        val byteBuf = toUtf8(value)
        // Ideally we'd pass these bytes to `ffi_bytebuffer_from_bytes`, but doing so would require us
        // to copy them into a JNA `Memory`. So we might as well directly copy them into a `RustBuffer`.
        val rbuf = RustBuffer.alloc(byteBuf.limit().toULong())
        rbuf.asByteBuffer()!!.put(byteBuf)
        return rbuf
    }

    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per UTF-16 code unit which will always be
    // enough.
    override fun allocationSize(value: String): ULong {
        val sizeForLength = 4UL
        val sizeForString = value.length.toULong() * 3UL
        return sizeForLength + sizeForString
    }

    override fun write(value: String, buf: ByteBuffer) {
        val byteBuf = toUtf8(value)
        buf.putInt(byteBuf.limit())
        buf.put(byteBuf)
    }
}

/**
 * @suppress
 */
public object FfiConverterByteArray: FfiConverterRustBuffer<ByteArray> {
    override fun read(buf: ByteBuffer): ByteArray {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr
    }
    override fun allocationSize(value: ByteArray): ULong {
        return 4UL + value.size.toULong()
    }
    override fun write(value: ByteArray, buf: ByteBuffer) {
        buf.putInt(value.size)
        buf.put(value)
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface BlobsRepoFfiInterface {
    
    suspend fun `getPath`(`hash`: kotlin.String): kotlin.String
    
    suspend fun `put`(`data`: kotlin.ByteArray): kotlin.String
    
    companion object
}

open class BlobsRepoFfi: Disposable, AutoCloseable, BlobsRepoFfiInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_daybook_ffi_fn_free_blobsrepoffi(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_daybook_ffi_fn_clone_blobsrepoffi(handle, status)
        }
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getPath`(`hash`: kotlin.String) : kotlin.String {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_blobsrepoffi_get_path(
                uniffiHandle,
                FfiConverterString.lower(`hash`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterString.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `put`(`data`: kotlin.ByteArray) : kotlin.String {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_blobsrepoffi_put(
                uniffiHandle,
                FfiConverterByteArray.lower(`data`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterString.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    

    


    
    companion object {
        
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `load`(`fcx`: FfiCtx) : BlobsRepoFfi {
        return uniffiRustCallAsync(
        UniffiLib.uniffi_daybook_ffi_fn_constructor_blobsrepoffi_load(FfiConverterTypeFfiCtx.lower(`fcx`),),
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_u64(future) },
        // lift function
        { FfiConverterTypeBlobsRepoFfi.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeBlobsRepoFfi: FfiConverter<BlobsRepoFfi, Long> {
    override fun lower(value: BlobsRepoFfi): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): BlobsRepoFfi {
        return BlobsRepoFfi(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): BlobsRepoFfi {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: BlobsRepoFfi) = 8UL

    override fun write(value: BlobsRepoFfi, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface CameraPreviewFfiInterface {
    
    fun `latestFrame`(): CameraPreviewFrame?
    
    fun `listDevices`(): List<CameraDeviceInfo>
    
    fun `startStream`(`deviceId`: kotlin.UInt, `listener`: CameraPreviewFrameListener)
    
    fun `stopStream`()
    
    fun `takeLatestFrame`(): CameraPreviewFrame?
    
    companion object
}

open class CameraPreviewFfi: Disposable, AutoCloseable, CameraPreviewFfiInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_daybook_ffi_fn_free_camerapreviewffi(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_daybook_ffi_fn_clone_camerapreviewffi(handle, status)
        }
    }

    override fun `latestFrame`(): CameraPreviewFrame? {
            return FfiConverterOptionalTypeCameraPreviewFrame.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_daybook_ffi_fn_method_camerapreviewffi_latest_frame(
        it,
        _status)
}
    }
    )
    }
    

    
    @Throws(FfiException::class)override fun `listDevices`(): List<CameraDeviceInfo> {
            return FfiConverterSequenceTypeCameraDeviceInfo.lift(
    callWithHandle {
    uniffiRustCallWithError(FfiException) { _status ->
    UniffiLib.uniffi_daybook_ffi_fn_method_camerapreviewffi_list_devices(
        it,
        _status)
}
    }
    )
    }
    

    
    @Throws(FfiException::class)override fun `startStream`(`deviceId`: kotlin.UInt, `listener`: CameraPreviewFrameListener)
        = 
    callWithHandle {
    uniffiRustCallWithError(FfiException) { _status ->
    UniffiLib.uniffi_daybook_ffi_fn_method_camerapreviewffi_start_stream(
        it,
        FfiConverterUInt.lower(`deviceId`),FfiConverterTypeCameraPreviewFrameListener.lower(`listener`),_status)
}
    }
    
    

    
    @Throws(FfiException::class)override fun `stopStream`()
        = 
    callWithHandle {
    uniffiRustCallWithError(FfiException) { _status ->
    UniffiLib.uniffi_daybook_ffi_fn_method_camerapreviewffi_stop_stream(
        it,
        _status)
}
    }
    
    

    override fun `takeLatestFrame`(): CameraPreviewFrame? {
            return FfiConverterOptionalTypeCameraPreviewFrame.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_daybook_ffi_fn_method_camerapreviewffi_take_latest_frame(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    companion object {
         fun `load`(): CameraPreviewFfi {
            return FfiConverterTypeCameraPreviewFfi.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_daybook_ffi_fn_constructor_camerapreviewffi_load(
    
        _status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeCameraPreviewFfi: FfiConverter<CameraPreviewFfi, Long> {
    override fun lower(value: CameraPreviewFfi): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): CameraPreviewFfi {
        return CameraPreviewFfi(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): CameraPreviewFfi {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: CameraPreviewFfi) = 8UL

    override fun write(value: CameraPreviewFfi, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface CameraPreviewFrameListener {
    
    fun `onCameraPreviewFrame`(`frame`: CameraPreviewFrame)
    
    companion object
}

open class CameraPreviewFrameListenerImpl: Disposable, AutoCloseable, CameraPreviewFrameListener
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_daybook_ffi_fn_free_camerapreviewframelistener(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_daybook_ffi_fn_clone_camerapreviewframelistener(handle, status)
        }
    }

    override fun `onCameraPreviewFrame`(`frame`: CameraPreviewFrame)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_daybook_ffi_fn_method_camerapreviewframelistener_on_camera_preview_frame(
        it,
        FfiConverterTypeCameraPreviewFrame.lower(`frame`),_status)
}
    }
    
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceCameraPreviewFrameListener {
    internal object `onCameraPreviewFrame`: UniffiCallbackInterfaceCameraPreviewFrameListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`frame`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeCameraPreviewFrameListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onCameraPreviewFrame`(
                    FfiConverterTypeCameraPreviewFrame.lift(`frame`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeCameraPreviewFrameListener.handleMap.remove(handle)
        }
    }

    internal object uniffiClone: UniffiCallbackInterfaceClone {
        override fun callback(handle: Long): Long {
            return FfiConverterTypeCameraPreviewFrameListener.handleMap.clone(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceCameraPreviewFrameListener.UniffiByValue(
        uniffiFree,
        uniffiClone,
        `onCameraPreviewFrame`,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_daybook_ffi_fn_init_callback_vtable_camerapreviewframelistener(vtable)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeCameraPreviewFrameListener: FfiConverter<CameraPreviewFrameListener, Long> {
    internal val handleMap = UniffiHandleMap<CameraPreviewFrameListener>()

    override fun lower(value: CameraPreviewFrameListener): Long {
        if (value is CameraPreviewFrameListenerImpl) {
             // Rust-implemented object.  Clone the handle and return it
            return value.uniffiCloneHandle()
         } else {
            // Kotlin object, generate a new vtable handle and return that.
            return handleMap.insert(value)
         }
    }

    override fun lift(value: Long): CameraPreviewFrameListener {
        if ((value and 1.toLong()) == 0.toLong()) {
            // Rust-generated handle, construct a new class that uses the handle to implement the
            // interface
            return CameraPreviewFrameListenerImpl(UniffiWithHandle, value)
        } else {
            // Kotlin-generated handle, get the object from the handle map
            return handleMap.remove(value)
        }
    }

    override fun read(buf: ByteBuffer): CameraPreviewFrameListener {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: CameraPreviewFrameListener) = 8UL

    override fun write(value: CameraPreviewFrameListener, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface ConfigEventListener {
    
    fun `onConfigEvent`(`event`: ConfigEvent)
    
    companion object
}

open class ConfigEventListenerImpl: Disposable, AutoCloseable, ConfigEventListener
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_daybook_ffi_fn_free_configeventlistener(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_daybook_ffi_fn_clone_configeventlistener(handle, status)
        }
    }

    override fun `onConfigEvent`(`event`: ConfigEvent)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_daybook_ffi_fn_method_configeventlistener_on_config_event(
        it,
        FfiConverterTypeConfigEvent.lower(`event`),_status)
}
    }
    
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceConfigEventListener {
    internal object `onConfigEvent`: UniffiCallbackInterfaceConfigEventListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`event`: RustBufferConfigEvent.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeConfigEventListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onConfigEvent`(
                    FfiConverterTypeConfigEvent.lift(`event`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeConfigEventListener.handleMap.remove(handle)
        }
    }

    internal object uniffiClone: UniffiCallbackInterfaceClone {
        override fun callback(handle: Long): Long {
            return FfiConverterTypeConfigEventListener.handleMap.clone(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceConfigEventListener.UniffiByValue(
        uniffiFree,
        uniffiClone,
        `onConfigEvent`,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_daybook_ffi_fn_init_callback_vtable_configeventlistener(vtable)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeConfigEventListener: FfiConverter<ConfigEventListener, Long> {
    internal val handleMap = UniffiHandleMap<ConfigEventListener>()

    override fun lower(value: ConfigEventListener): Long {
        if (value is ConfigEventListenerImpl) {
             // Rust-implemented object.  Clone the handle and return it
            return value.uniffiCloneHandle()
         } else {
            // Kotlin object, generate a new vtable handle and return that.
            return handleMap.insert(value)
         }
    }

    override fun lift(value: Long): ConfigEventListener {
        if ((value and 1.toLong()) == 0.toLong()) {
            // Rust-generated handle, construct a new class that uses the handle to implement the
            // interface
            return ConfigEventListenerImpl(UniffiWithHandle, value)
        } else {
            // Kotlin-generated handle, get the object from the handle map
            return handleMap.remove(value)
        }
    }

    override fun read(buf: ByteBuffer): ConfigEventListener {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: ConfigEventListener) = 8UL

    override fun write(value: ConfigEventListener, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface ConfigRepoFfiInterface {
    
    fun `ffiRegisterListener`(`listener`: ConfigEventListener): ListenerRegistration
    
    suspend fun `getFacetDisplayHint`(`id`: kotlin.String): FacetDisplayHint?
    
    suspend fun `listDisplayHints`(): Map<kotlin.String, FacetDisplayHint>
    
    suspend fun `setFacetDisplayHint`(`key`: kotlin.String, `config`: FacetDisplayHint)
    
    suspend fun `stop`()
    
    companion object
}

open class ConfigRepoFfi: Disposable, AutoCloseable, ConfigRepoFfiInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_daybook_ffi_fn_free_configrepoffi(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_daybook_ffi_fn_clone_configrepoffi(handle, status)
        }
    }

    override fun `ffiRegisterListener`(`listener`: ConfigEventListener): ListenerRegistration {
            return FfiConverterTypeListenerRegistration.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_daybook_ffi_fn_method_configrepoffi_ffi_register_listener(
        it,
        FfiConverterTypeConfigEventListener.lower(`listener`),_status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getFacetDisplayHint`(`id`: kotlin.String) : FacetDisplayHint? {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_configrepoffi_get_facet_display_hint(
                uniffiHandle,
                FfiConverterString.lower(`id`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeFacetDisplayHint.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `listDisplayHints`() : Map<kotlin.String, FacetDisplayHint> {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_configrepoffi_list_display_hints(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterMapStringTypeFacetDisplayHint.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setFacetDisplayHint`(`key`: kotlin.String, `config`: FacetDisplayHint) {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_configrepoffi_set_facet_display_hint(
                uniffiHandle,
                FfiConverterString.lower(`key`),FfiConverterTypeFacetDisplayHint.lower(`config`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `stop`() {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_configrepoffi_stop(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    

    


    
    companion object {
        
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `load`(`fcx`: FfiCtx, `plugRepo`: PlugsRepoFfi) : ConfigRepoFfi {
        return uniffiRustCallAsync(
        UniffiLib.uniffi_daybook_ffi_fn_constructor_configrepoffi_load(FfiConverterTypeFfiCtx.lower(`fcx`),FfiConverterTypePlugsRepoFfi.lower(`plugRepo`),),
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_u64(future) },
        // lift function
        { FfiConverterTypeConfigRepoFfi.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeConfigRepoFfi: FfiConverter<ConfigRepoFfi, Long> {
    override fun lower(value: ConfigRepoFfi): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): ConfigRepoFfi {
        return ConfigRepoFfi(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): ConfigRepoFfi {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: ConfigRepoFfi) = 8UL

    override fun write(value: ConfigRepoFfi, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface DispatchEventListener {
    
    fun `onDispatchEvent`(`event`: DispatchEvent)
    
    companion object
}

open class DispatchEventListenerImpl: Disposable, AutoCloseable, DispatchEventListener
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_daybook_ffi_fn_free_dispatcheventlistener(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_daybook_ffi_fn_clone_dispatcheventlistener(handle, status)
        }
    }

    override fun `onDispatchEvent`(`event`: DispatchEvent)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_daybook_ffi_fn_method_dispatcheventlistener_on_dispatch_event(
        it,
        FfiConverterTypeDispatchEvent.lower(`event`),_status)
}
    }
    
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceDispatchEventListener {
    internal object `onDispatchEvent`: UniffiCallbackInterfaceDispatchEventListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`event`: RustBufferDispatchEvent.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeDispatchEventListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onDispatchEvent`(
                    FfiConverterTypeDispatchEvent.lift(`event`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeDispatchEventListener.handleMap.remove(handle)
        }
    }

    internal object uniffiClone: UniffiCallbackInterfaceClone {
        override fun callback(handle: Long): Long {
            return FfiConverterTypeDispatchEventListener.handleMap.clone(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceDispatchEventListener.UniffiByValue(
        uniffiFree,
        uniffiClone,
        `onDispatchEvent`,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_daybook_ffi_fn_init_callback_vtable_dispatcheventlistener(vtable)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeDispatchEventListener: FfiConverter<DispatchEventListener, Long> {
    internal val handleMap = UniffiHandleMap<DispatchEventListener>()

    override fun lower(value: DispatchEventListener): Long {
        if (value is DispatchEventListenerImpl) {
             // Rust-implemented object.  Clone the handle and return it
            return value.uniffiCloneHandle()
         } else {
            // Kotlin object, generate a new vtable handle and return that.
            return handleMap.insert(value)
         }
    }

    override fun lift(value: Long): DispatchEventListener {
        if ((value and 1.toLong()) == 0.toLong()) {
            // Rust-generated handle, construct a new class that uses the handle to implement the
            // interface
            return DispatchEventListenerImpl(UniffiWithHandle, value)
        } else {
            // Kotlin-generated handle, get the object from the handle map
            return handleMap.remove(value)
        }
    }

    override fun read(buf: ByteBuffer): DispatchEventListener {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: DispatchEventListener) = 8UL

    override fun write(value: DispatchEventListener, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface DispatchRepoFfiInterface {
    
    fun `ffiRegisterListener`(`listener`: DispatchEventListener): ListenerRegistration
    
    suspend fun `list`(): List<kotlin.String>
    
    suspend fun `stop`()
    
    companion object
}

open class DispatchRepoFfi: Disposable, AutoCloseable, DispatchRepoFfiInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_daybook_ffi_fn_free_dispatchrepoffi(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_daybook_ffi_fn_clone_dispatchrepoffi(handle, status)
        }
    }

    override fun `ffiRegisterListener`(`listener`: DispatchEventListener): ListenerRegistration {
            return FfiConverterTypeListenerRegistration.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_daybook_ffi_fn_method_dispatchrepoffi_ffi_register_listener(
        it,
        FfiConverterTypeDispatchEventListener.lower(`listener`),_status)
}
    }
    )
    }
    

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `list`() : List<kotlin.String> {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_dispatchrepoffi_list(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterSequenceString.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `stop`() {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_dispatchrepoffi_stop(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    

    


    
    companion object {
        
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `load`(`fcx`: FfiCtx) : DispatchRepoFfi {
        return uniffiRustCallAsync(
        UniffiLib.uniffi_daybook_ffi_fn_constructor_dispatchrepoffi_load(FfiConverterTypeFfiCtx.lower(`fcx`),),
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_u64(future) },
        // lift function
        { FfiConverterTypeDispatchRepoFfi.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeDispatchRepoFfi: FfiConverter<DispatchRepoFfi, Long> {
    override fun lower(value: DispatchRepoFfi): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): DispatchRepoFfi {
        return DispatchRepoFfi(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): DispatchRepoFfi {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: DispatchRepoFfi) = 8UL

    override fun write(value: DispatchRepoFfi, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface DrawerEventListener {
    
    fun `onDrawerEvent`(`event`: DrawerEvent)
    
    companion object
}

open class DrawerEventListenerImpl: Disposable, AutoCloseable, DrawerEventListener
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_daybook_ffi_fn_free_drawereventlistener(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_daybook_ffi_fn_clone_drawereventlistener(handle, status)
        }
    }

    override fun `onDrawerEvent`(`event`: DrawerEvent)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_daybook_ffi_fn_method_drawereventlistener_on_drawer_event(
        it,
        FfiConverterTypeDrawerEvent.lower(`event`),_status)
}
    }
    
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceDrawerEventListener {
    internal object `onDrawerEvent`: UniffiCallbackInterfaceDrawerEventListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`event`: RustBufferDrawerEvent.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeDrawerEventListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onDrawerEvent`(
                    FfiConverterTypeDrawerEvent.lift(`event`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeDrawerEventListener.handleMap.remove(handle)
        }
    }

    internal object uniffiClone: UniffiCallbackInterfaceClone {
        override fun callback(handle: Long): Long {
            return FfiConverterTypeDrawerEventListener.handleMap.clone(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceDrawerEventListener.UniffiByValue(
        uniffiFree,
        uniffiClone,
        `onDrawerEvent`,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_daybook_ffi_fn_init_callback_vtable_drawereventlistener(vtable)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeDrawerEventListener: FfiConverter<DrawerEventListener, Long> {
    internal val handleMap = UniffiHandleMap<DrawerEventListener>()

    override fun lower(value: DrawerEventListener): Long {
        if (value is DrawerEventListenerImpl) {
             // Rust-implemented object.  Clone the handle and return it
            return value.uniffiCloneHandle()
         } else {
            // Kotlin object, generate a new vtable handle and return that.
            return handleMap.insert(value)
         }
    }

    override fun lift(value: Long): DrawerEventListener {
        if ((value and 1.toLong()) == 0.toLong()) {
            // Rust-generated handle, construct a new class that uses the handle to implement the
            // interface
            return DrawerEventListenerImpl(UniffiWithHandle, value)
        } else {
            // Kotlin-generated handle, get the object from the handle map
            return handleMap.remove(value)
        }
    }

    override fun read(buf: ByteBuffer): DrawerEventListener {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: DrawerEventListener) = 8UL

    override fun write(value: DrawerEventListener, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface DrawerRepoFfiInterface {
    
    suspend fun `add`(`args`: AddDocArgs): kotlin.String
    
    suspend fun `del`(`id`: kotlin.String): kotlin.Boolean
    
    fun `ffiRegisterListener`(`listener`: DrawerEventListener): ListenerRegistration
    
    suspend fun `get`(`id`: kotlin.String, `branchPath`: kotlin.String): Doc?
    
    suspend fun `list`(): List<DocNBranches>
    
    suspend fun `stop`()
    
    suspend fun `update`(`patch`: DocPatch, `branchPath`: kotlin.String, `heads`: ChangeHashSet?)
    
    suspend fun `updateBatch`(`patches`: List<UpdateDocArgsV2>)
    
    companion object
}

open class DrawerRepoFfi: Disposable, AutoCloseable, DrawerRepoFfiInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_daybook_ffi_fn_free_drawerrepoffi(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_daybook_ffi_fn_clone_drawerrepoffi(handle, status)
        }
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `add`(`args`: AddDocArgs) : kotlin.String {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_drawerrepoffi_add(
                uniffiHandle,
                FfiConverterTypeAddDocArgs.lower(`args`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterString.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `del`(`id`: kotlin.String) : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_drawerrepoffi_del(
                uniffiHandle,
                FfiConverterString.lower(`id`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    override fun `ffiRegisterListener`(`listener`: DrawerEventListener): ListenerRegistration {
            return FfiConverterTypeListenerRegistration.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_daybook_ffi_fn_method_drawerrepoffi_ffi_register_listener(
        it,
        FfiConverterTypeDrawerEventListener.lower(`listener`),_status)
}
    }
    )
    }
    

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `get`(`id`: kotlin.String, `branchPath`: kotlin.String) : Doc? {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_drawerrepoffi_get(
                uniffiHandle,
                FfiConverterString.lower(`id`),FfiConverterString.lower(`branchPath`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeDoc.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `list`() : List<DocNBranches> {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_drawerrepoffi_list(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterSequenceTypeDocNBranches.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `stop`() {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_drawerrepoffi_stop(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `update`(`patch`: DocPatch, `branchPath`: kotlin.String, `heads`: ChangeHashSet?) {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_drawerrepoffi_update(
                uniffiHandle,
                FfiConverterTypeDocPatch.lower(`patch`),FfiConverterString.lower(`branchPath`),FfiConverterOptionalTypeChangeHashSet.lower(`heads`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `updateBatch`(`patches`: List<UpdateDocArgsV2>) {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_drawerrepoffi_update_batch(
                uniffiHandle,
                FfiConverterSequenceTypeUpdateDocArgsV2.lower(`patches`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    

    


    
    companion object {
        
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `load`(`fcx`: FfiCtx, `plugsRepo`: PlugsRepoFfi) : DrawerRepoFfi {
        return uniffiRustCallAsync(
        UniffiLib.uniffi_daybook_ffi_fn_constructor_drawerrepoffi_load(FfiConverterTypeFfiCtx.lower(`fcx`),FfiConverterTypePlugsRepoFfi.lower(`plugsRepo`),),
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_u64(future) },
        // lift function
        { FfiConverterTypeDrawerRepoFfi.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeDrawerRepoFfi: FfiConverter<DrawerRepoFfi, Long> {
    override fun lower(value: DrawerRepoFfi): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): DrawerRepoFfi {
        return DrawerRepoFfi(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): DrawerRepoFfi {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: DrawerRepoFfi) = 8UL

    override fun write(value: DrawerRepoFfi, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface FfiCtxInterface {
    
    suspend fun `getLastUsedRepo`(): KnownRepoEntryFfi?
    
    suspend fun `isRepoUsable`(`repoRoot`: kotlin.String): kotlin.Boolean
    
    suspend fun `listKnownRepos`(): List<KnownRepoEntryFfi>
    
    suspend fun `registerRepoPath`(`repoRoot`: kotlin.String): KnownRepoEntryFfi
    
    companion object
}

open class FfiCtx: Disposable, AutoCloseable, FfiCtxInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_daybook_ffi_fn_free_ffictx(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_daybook_ffi_fn_clone_ffictx(handle, status)
        }
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getLastUsedRepo`() : KnownRepoEntryFfi? {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_ffictx_get_last_used_repo(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeKnownRepoEntryFfi.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `isRepoUsable`(`repoRoot`: kotlin.String) : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_ffictx_is_repo_usable(
                uniffiHandle,
                FfiConverterString.lower(`repoRoot`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `listKnownRepos`() : List<KnownRepoEntryFfi> {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_ffictx_list_known_repos(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterSequenceTypeKnownRepoEntryFfi.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `registerRepoPath`(`repoRoot`: kotlin.String) : KnownRepoEntryFfi {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_ffictx_register_repo_path(
                uniffiHandle,
                FfiConverterString.lower(`repoRoot`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeKnownRepoEntryFfi.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    

    


    
    companion object {
        
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `forFfi`() : FfiCtx {
        return uniffiRustCallAsync(
        UniffiLib.uniffi_daybook_ffi_fn_constructor_ffictx_for_ffi(),
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_u64(future) },
        // lift function
        { FfiConverterTypeFfiCtx.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

        
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `forGlobals`() : FfiCtx {
        return uniffiRustCallAsync(
        UniffiLib.uniffi_daybook_ffi_fn_constructor_ffictx_for_globals(),
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_u64(future) },
        // lift function
        { FfiConverterTypeFfiCtx.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

        
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `forRepoRoot`(`repoRoot`: kotlin.String) : FfiCtx {
        return uniffiRustCallAsync(
        UniffiLib.uniffi_daybook_ffi_fn_constructor_ffictx_for_repo_root(FfiConverterString.lower(`repoRoot`),),
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_u64(future) },
        // lift function
        { FfiConverterTypeFfiCtx.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeFfiCtx: FfiConverter<FfiCtx, Long> {
    override fun lower(value: FfiCtx): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): FfiCtx {
        return FfiCtx(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): FfiCtx {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: FfiCtx) = 8UL

    override fun write(value: FfiCtx, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface FfiExceptionInterface {
    
    fun `message`(): kotlin.String
    
    companion object
}


open class FfiException : kotlin.Exception, Disposable, AutoCloseable, FfiExceptionInterface {


    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_daybook_ffi_fn_free_ffierror(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_daybook_ffi_fn_clone_ffierror(handle, status)
        }
    }

    override fun `message`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_daybook_ffi_fn_method_ffierror_message(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    
    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<FfiException> {
        override fun lift(error_buf: RustBuffer.ByValue): FfiException {
            // Due to some mismatches in the ffi converter mechanisms, errors are a RustBuffer.
            val bb = error_buf.asByteBuffer()
            if (bb == null) {
                throw InternalException("?")
            }
            return FfiConverterTypeFfiError.read(bb)
        }
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeFfiError: FfiConverter<FfiException, Long> {
    override fun lower(value: FfiException): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): FfiException {
        return FfiException(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): FfiException {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: FfiException) = 8UL

    override fun write(value: FfiException, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface PlugsEventListener {
    
    fun `onPlugsEvent`(`event`: PlugsEvent)
    
    companion object
}

open class PlugsEventListenerImpl: Disposable, AutoCloseable, PlugsEventListener
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_daybook_ffi_fn_free_plugseventlistener(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_daybook_ffi_fn_clone_plugseventlistener(handle, status)
        }
    }

    override fun `onPlugsEvent`(`event`: PlugsEvent)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_daybook_ffi_fn_method_plugseventlistener_on_plugs_event(
        it,
        FfiConverterTypePlugsEvent.lower(`event`),_status)
}
    }
    
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfacePlugsEventListener {
    internal object `onPlugsEvent`: UniffiCallbackInterfacePlugsEventListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`event`: RustBufferPlugsEvent.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypePlugsEventListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onPlugsEvent`(
                    FfiConverterTypePlugsEvent.lift(`event`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypePlugsEventListener.handleMap.remove(handle)
        }
    }

    internal object uniffiClone: UniffiCallbackInterfaceClone {
        override fun callback(handle: Long): Long {
            return FfiConverterTypePlugsEventListener.handleMap.clone(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfacePlugsEventListener.UniffiByValue(
        uniffiFree,
        uniffiClone,
        `onPlugsEvent`,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_daybook_ffi_fn_init_callback_vtable_plugseventlistener(vtable)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypePlugsEventListener: FfiConverter<PlugsEventListener, Long> {
    internal val handleMap = UniffiHandleMap<PlugsEventListener>()

    override fun lower(value: PlugsEventListener): Long {
        if (value is PlugsEventListenerImpl) {
             // Rust-implemented object.  Clone the handle and return it
            return value.uniffiCloneHandle()
         } else {
            // Kotlin object, generate a new vtable handle and return that.
            return handleMap.insert(value)
         }
    }

    override fun lift(value: Long): PlugsEventListener {
        if ((value and 1.toLong()) == 0.toLong()) {
            // Rust-generated handle, construct a new class that uses the handle to implement the
            // interface
            return PlugsEventListenerImpl(UniffiWithHandle, value)
        } else {
            // Kotlin-generated handle, get the object from the handle map
            return handleMap.remove(value)
        }
    }

    override fun read(buf: ByteBuffer): PlugsEventListener {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: PlugsEventListener) = 8UL

    override fun write(value: PlugsEventListener, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface PlugsRepoFfiInterface {
    
    fun `ffiRegisterListener`(`listener`: PlugsEventListener): ListenerRegistration
    
    suspend fun `stop`()
    
    companion object
}

open class PlugsRepoFfi: Disposable, AutoCloseable, PlugsRepoFfiInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_daybook_ffi_fn_free_plugsrepoffi(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_daybook_ffi_fn_clone_plugsrepoffi(handle, status)
        }
    }

    override fun `ffiRegisterListener`(`listener`: PlugsEventListener): ListenerRegistration {
            return FfiConverterTypeListenerRegistration.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_daybook_ffi_fn_method_plugsrepoffi_ffi_register_listener(
        it,
        FfiConverterTypePlugsEventListener.lower(`listener`),_status)
}
    }
    )
    }
    

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `stop`() {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_plugsrepoffi_stop(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    

    


    
    companion object {
        
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `load`(`fcx`: FfiCtx, `blobsRepo`: BlobsRepoFfi) : PlugsRepoFfi {
        return uniffiRustCallAsync(
        UniffiLib.uniffi_daybook_ffi_fn_constructor_plugsrepoffi_load(FfiConverterTypeFfiCtx.lower(`fcx`),FfiConverterTypeBlobsRepoFfi.lower(`blobsRepo`),),
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_u64(future) },
        // lift function
        { FfiConverterTypePlugsRepoFfi.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypePlugsRepoFfi: FfiConverter<PlugsRepoFfi, Long> {
    override fun lower(value: PlugsRepoFfi): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): PlugsRepoFfi {
        return PlugsRepoFfi(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): PlugsRepoFfi {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: PlugsRepoFfi) = 8UL

    override fun write(value: PlugsRepoFfi, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface ProgressEventListener {
    
    fun `onProgressEvent`(`event`: ProgressEvent)
    
    companion object
}

open class ProgressEventListenerImpl: Disposable, AutoCloseable, ProgressEventListener
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_daybook_ffi_fn_free_progresseventlistener(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_daybook_ffi_fn_clone_progresseventlistener(handle, status)
        }
    }

    override fun `onProgressEvent`(`event`: ProgressEvent)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_daybook_ffi_fn_method_progresseventlistener_on_progress_event(
        it,
        FfiConverterTypeProgressEvent.lower(`event`),_status)
}
    }
    
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceProgressEventListener {
    internal object `onProgressEvent`: UniffiCallbackInterfaceProgressEventListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`event`: RustBufferProgressEvent.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeProgressEventListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onProgressEvent`(
                    FfiConverterTypeProgressEvent.lift(`event`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeProgressEventListener.handleMap.remove(handle)
        }
    }

    internal object uniffiClone: UniffiCallbackInterfaceClone {
        override fun callback(handle: Long): Long {
            return FfiConverterTypeProgressEventListener.handleMap.clone(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceProgressEventListener.UniffiByValue(
        uniffiFree,
        uniffiClone,
        `onProgressEvent`,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_daybook_ffi_fn_init_callback_vtable_progresseventlistener(vtable)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeProgressEventListener: FfiConverter<ProgressEventListener, Long> {
    internal val handleMap = UniffiHandleMap<ProgressEventListener>()

    override fun lower(value: ProgressEventListener): Long {
        if (value is ProgressEventListenerImpl) {
             // Rust-implemented object.  Clone the handle and return it
            return value.uniffiCloneHandle()
         } else {
            // Kotlin object, generate a new vtable handle and return that.
            return handleMap.insert(value)
         }
    }

    override fun lift(value: Long): ProgressEventListener {
        if ((value and 1.toLong()) == 0.toLong()) {
            // Rust-generated handle, construct a new class that uses the handle to implement the
            // interface
            return ProgressEventListenerImpl(UniffiWithHandle, value)
        } else {
            // Kotlin-generated handle, get the object from the handle map
            return handleMap.remove(value)
        }
    }

    override fun read(buf: ByteBuffer): ProgressEventListener {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: ProgressEventListener) = 8UL

    override fun write(value: ProgressEventListener, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface ProgressRepoFfiInterface {
    
    suspend fun `clearCompleted`(): kotlin.ULong
    
    suspend fun `dismiss`(`id`: kotlin.String)
    
    suspend fun `ffiAddUpdate`(`id`: kotlin.String, `update`: ProgressUpdate)
    
    fun `ffiRegisterListener`(`listener`: ProgressEventListener): ListenerRegistration
    
    suspend fun `ffiUpsertTask`(`args`: CreateProgressTaskArgs)
    
    suspend fun `get`(`id`: kotlin.String): ProgressTask?
    
    suspend fun `list`(): List<ProgressTask>
    
    suspend fun `listByTagPrefix`(`tagPrefix`: kotlin.String): List<ProgressTask>
    
    suspend fun `listUpdates`(`id`: kotlin.String): List<ProgressUpdateEntry>
    
    suspend fun `markViewed`(`id`: kotlin.String)
    
    suspend fun `setRetentionOverride`(`id`: kotlin.String, `retention`: ProgressRetentionPolicy?)
    
    companion object
}

open class ProgressRepoFfi: Disposable, AutoCloseable, ProgressRepoFfiInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_daybook_ffi_fn_free_progressrepoffi(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_daybook_ffi_fn_clone_progressrepoffi(handle, status)
        }
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `clearCompleted`() : kotlin.ULong {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_progressrepoffi_clear_completed(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_u64(future) },
        // lift function
        { FfiConverterULong.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `dismiss`(`id`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_progressrepoffi_dismiss(
                uniffiHandle,
                FfiConverterString.lower(`id`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `ffiAddUpdate`(`id`: kotlin.String, `update`: ProgressUpdate) {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_progressrepoffi_ffi_add_update(
                uniffiHandle,
                FfiConverterString.lower(`id`),FfiConverterTypeProgressUpdate.lower(`update`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    override fun `ffiRegisterListener`(`listener`: ProgressEventListener): ListenerRegistration {
            return FfiConverterTypeListenerRegistration.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_daybook_ffi_fn_method_progressrepoffi_ffi_register_listener(
        it,
        FfiConverterTypeProgressEventListener.lower(`listener`),_status)
}
    }
    )
    }
    

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `ffiUpsertTask`(`args`: CreateProgressTaskArgs) {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_progressrepoffi_ffi_upsert_task(
                uniffiHandle,
                FfiConverterTypeCreateProgressTaskArgs.lower(`args`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `get`(`id`: kotlin.String) : ProgressTask? {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_progressrepoffi_get(
                uniffiHandle,
                FfiConverterString.lower(`id`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeProgressTask.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `list`() : List<ProgressTask> {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_progressrepoffi_list(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterSequenceTypeProgressTask.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `listByTagPrefix`(`tagPrefix`: kotlin.String) : List<ProgressTask> {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_progressrepoffi_list_by_tag_prefix(
                uniffiHandle,
                FfiConverterString.lower(`tagPrefix`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterSequenceTypeProgressTask.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `listUpdates`(`id`: kotlin.String) : List<ProgressUpdateEntry> {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_progressrepoffi_list_updates(
                uniffiHandle,
                FfiConverterString.lower(`id`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterSequenceTypeProgressUpdateEntry.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `markViewed`(`id`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_progressrepoffi_mark_viewed(
                uniffiHandle,
                FfiConverterString.lower(`id`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setRetentionOverride`(`id`: kotlin.String, `retention`: ProgressRetentionPolicy?) {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_progressrepoffi_set_retention_override(
                uniffiHandle,
                FfiConverterString.lower(`id`),FfiConverterOptionalTypeProgressRetentionPolicy.lower(`retention`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    

    


    
    companion object {
        
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `load`(`fcx`: FfiCtx) : ProgressRepoFfi {
        return uniffiRustCallAsync(
        UniffiLib.uniffi_daybook_ffi_fn_constructor_progressrepoffi_load(FfiConverterTypeFfiCtx.lower(`fcx`),),
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_u64(future) },
        // lift function
        { FfiConverterTypeProgressRepoFfi.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeProgressRepoFfi: FfiConverter<ProgressRepoFfi, Long> {
    override fun lower(value: ProgressRepoFfi): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): ProgressRepoFfi {
        return ProgressRepoFfi(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): ProgressRepoFfi {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: ProgressRepoFfi) = 8UL

    override fun write(value: ProgressRepoFfi, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface RtFfiInterface {
    
    suspend fun `dispatchDocFacet`(`plugId`: kotlin.String, `routineName`: kotlin.String, `docId`: kotlin.String, `branchPath`: kotlin.String): kotlin.String
    
    suspend fun `stop`()
    
    companion object
}

open class RtFfi: Disposable, AutoCloseable, RtFfiInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_daybook_ffi_fn_free_rtffi(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_daybook_ffi_fn_clone_rtffi(handle, status)
        }
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `dispatchDocFacet`(`plugId`: kotlin.String, `routineName`: kotlin.String, `docId`: kotlin.String, `branchPath`: kotlin.String) : kotlin.String {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_rtffi_dispatch_doc_facet(
                uniffiHandle,
                FfiConverterString.lower(`plugId`),FfiConverterString.lower(`routineName`),FfiConverterString.lower(`docId`),FfiConverterString.lower(`branchPath`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterString.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `stop`() {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_rtffi_stop(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    

    


    
    companion object {
        
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `load`(`fcx`: FfiCtx, `drawerRepo`: DrawerRepoFfi, `plugsRepo`: PlugsRepoFfi, `dispatchRepo`: DispatchRepoFfi, `progressRepo`: ProgressRepoFfi, `blobsRepo`: BlobsRepoFfi, `configRepo`: ConfigRepoFfi, `deviceId`: kotlin.String) : RtFfi {
        return uniffiRustCallAsync(
        UniffiLib.uniffi_daybook_ffi_fn_constructor_rtffi_load(FfiConverterTypeFfiCtx.lower(`fcx`),FfiConverterTypeDrawerRepoFfi.lower(`drawerRepo`),FfiConverterTypePlugsRepoFfi.lower(`plugsRepo`),FfiConverterTypeDispatchRepoFfi.lower(`dispatchRepo`),FfiConverterTypeProgressRepoFfi.lower(`progressRepo`),FfiConverterTypeBlobsRepoFfi.lower(`blobsRepo`),FfiConverterTypeConfigRepoFfi.lower(`configRepo`),FfiConverterString.lower(`deviceId`),),
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_u64(future) },
        // lift function
        { FfiConverterTypeRtFfi.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeRtFfi: FfiConverter<RtFfi, Long> {
    override fun lower(value: RtFfi): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): RtFfi {
        return RtFfi(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): RtFfi {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: RtFfi) = 8UL

    override fun write(value: RtFfi, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface TablesEventListener {
    
    fun `onTablesEvent`(`event`: TablesEvent)
    
    companion object
}

open class TablesEventListenerImpl: Disposable, AutoCloseable, TablesEventListener
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_daybook_ffi_fn_free_tableseventlistener(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_daybook_ffi_fn_clone_tableseventlistener(handle, status)
        }
    }

    override fun `onTablesEvent`(`event`: TablesEvent)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_daybook_ffi_fn_method_tableseventlistener_on_tables_event(
        it,
        FfiConverterTypeTablesEvent.lower(`event`),_status)
}
    }
    
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceTablesEventListener {
    internal object `onTablesEvent`: UniffiCallbackInterfaceTablesEventListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`event`: RustBufferTablesEvent.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeTablesEventListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onTablesEvent`(
                    FfiConverterTypeTablesEvent.lift(`event`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeTablesEventListener.handleMap.remove(handle)
        }
    }

    internal object uniffiClone: UniffiCallbackInterfaceClone {
        override fun callback(handle: Long): Long {
            return FfiConverterTypeTablesEventListener.handleMap.clone(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceTablesEventListener.UniffiByValue(
        uniffiFree,
        uniffiClone,
        `onTablesEvent`,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_daybook_ffi_fn_init_callback_vtable_tableseventlistener(vtable)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeTablesEventListener: FfiConverter<TablesEventListener, Long> {
    internal val handleMap = UniffiHandleMap<TablesEventListener>()

    override fun lower(value: TablesEventListener): Long {
        if (value is TablesEventListenerImpl) {
             // Rust-implemented object.  Clone the handle and return it
            return value.uniffiCloneHandle()
         } else {
            // Kotlin object, generate a new vtable handle and return that.
            return handleMap.insert(value)
         }
    }

    override fun lift(value: Long): TablesEventListener {
        if ((value and 1.toLong()) == 0.toLong()) {
            // Rust-generated handle, construct a new class that uses the handle to implement the
            // interface
            return TablesEventListenerImpl(UniffiWithHandle, value)
        } else {
            // Kotlin-generated handle, get the object from the handle map
            return handleMap.remove(value)
        }
    }

    override fun read(buf: ByteBuffer): TablesEventListener {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: TablesEventListener) = 8UL

    override fun write(value: TablesEventListener, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface TablesRepoFfiInterface {
    
    suspend fun `createNewTab`(`tableId`: Uuid): Uuid
    
    suspend fun `createNewTable`(): Uuid
    
    fun `ffiRegisterListener`(`listener`: TablesEventListener): ListenerRegistration
    
    suspend fun `getPanel`(`id`: Uuid): Panel?
    
    suspend fun `getSelectedTable`(): Table?
    
    suspend fun `getTab`(`id`: Uuid): Tab?
    
    suspend fun `getTable`(`id`: Uuid): Table?
    
    suspend fun `getWindow`(`id`: Uuid): Window?
    
    suspend fun `listPanels`(): List<Panel>
    
    suspend fun `listTables`(): List<Table>
    
    suspend fun `listTabs`(): List<Tab>
    
    suspend fun `listWindows`(): List<Window>
    
    suspend fun `removeTab`(`tabId`: Uuid)
    
    suspend fun `setPanel`(`id`: Uuid, `panel`: Panel): Panel?
    
    suspend fun `setTab`(`id`: Uuid, `tab`: Tab): Tab?
    
    suspend fun `setTable`(`id`: Uuid, `table`: Table): Table?
    
    suspend fun `setWindow`(`id`: Uuid, `window`: Window): Window?
    
    suspend fun `stop`()
    
    suspend fun `updateBatch`(`patches`: TablesPatches)
    
    companion object
}

open class TablesRepoFfi: Disposable, AutoCloseable, TablesRepoFfiInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_daybook_ffi_fn_free_tablesrepoffi(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_daybook_ffi_fn_clone_tablesrepoffi(handle, status)
        }
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `createNewTab`(`tableId`: Uuid) : Uuid {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_tablesrepoffi_create_new_tab(
                uniffiHandle,
                FfiConverterTypeUuid.lower(`tableId`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeUuid.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `createNewTable`() : Uuid {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_tablesrepoffi_create_new_table(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeUuid.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    override fun `ffiRegisterListener`(`listener`: TablesEventListener): ListenerRegistration {
            return FfiConverterTypeListenerRegistration.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_daybook_ffi_fn_method_tablesrepoffi_ffi_register_listener(
        it,
        FfiConverterTypeTablesEventListener.lower(`listener`),_status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getPanel`(`id`: Uuid) : Panel? {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_tablesrepoffi_get_panel(
                uniffiHandle,
                FfiConverterTypeUuid.lower(`id`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypePanel.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getSelectedTable`() : Table? {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_tablesrepoffi_get_selected_table(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeTable.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getTab`(`id`: Uuid) : Tab? {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_tablesrepoffi_get_tab(
                uniffiHandle,
                FfiConverterTypeUuid.lower(`id`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeTab.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getTable`(`id`: Uuid) : Table? {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_tablesrepoffi_get_table(
                uniffiHandle,
                FfiConverterTypeUuid.lower(`id`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeTable.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getWindow`(`id`: Uuid) : Window? {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_tablesrepoffi_get_window(
                uniffiHandle,
                FfiConverterTypeUuid.lower(`id`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeWindow.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `listPanels`() : List<Panel> {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_tablesrepoffi_list_panels(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterSequenceTypePanel.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `listTables`() : List<Table> {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_tablesrepoffi_list_tables(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterSequenceTypeTable.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `listTabs`() : List<Tab> {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_tablesrepoffi_list_tabs(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterSequenceTypeTab.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `listWindows`() : List<Window> {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_tablesrepoffi_list_windows(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterSequenceTypeWindow.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `removeTab`(`tabId`: Uuid) {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_tablesrepoffi_remove_tab(
                uniffiHandle,
                FfiConverterTypeUuid.lower(`tabId`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setPanel`(`id`: Uuid, `panel`: Panel) : Panel? {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_tablesrepoffi_set_panel(
                uniffiHandle,
                FfiConverterTypeUuid.lower(`id`),FfiConverterTypePanel.lower(`panel`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypePanel.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setTab`(`id`: Uuid, `tab`: Tab) : Tab? {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_tablesrepoffi_set_tab(
                uniffiHandle,
                FfiConverterTypeUuid.lower(`id`),FfiConverterTypeTab.lower(`tab`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeTab.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setTable`(`id`: Uuid, `table`: Table) : Table? {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_tablesrepoffi_set_table(
                uniffiHandle,
                FfiConverterTypeUuid.lower(`id`),FfiConverterTypeTable.lower(`table`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeTable.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setWindow`(`id`: Uuid, `window`: Window) : Window? {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_tablesrepoffi_set_window(
                uniffiHandle,
                FfiConverterTypeUuid.lower(`id`),FfiConverterTypeWindow.lower(`window`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeWindow.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `stop`() {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_tablesrepoffi_stop(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `updateBatch`(`patches`: TablesPatches) {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.uniffi_daybook_ffi_fn_method_tablesrepoffi_update_batch(
                uniffiHandle,
                FfiConverterTypeTablesPatches.lower(`patches`),
            )
        },
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

    

    


    
    companion object {
        
    @Throws(FfiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `load`(`fcx`: FfiCtx) : TablesRepoFfi {
        return uniffiRustCallAsync(
        UniffiLib.uniffi_daybook_ffi_fn_constructor_tablesrepoffi_load(FfiConverterTypeFfiCtx.lower(`fcx`),),
        { future, callback, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.ffi_daybook_ffi_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.ffi_daybook_ffi_rust_future_free_u64(future) },
        // lift function
        { FfiConverterTypeTablesRepoFfi.lift(it) },
        // Error FFI converter
        FfiException.ErrorHandler,
    )
    }

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeTablesRepoFfi: FfiConverter<TablesRepoFfi, Long> {
    override fun lower(value: TablesRepoFfi): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): TablesRepoFfi {
        return TablesRepoFfi(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): TablesRepoFfi {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: TablesRepoFfi) = 8UL

    override fun write(value: TablesRepoFfi, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}



data class CameraDeviceInfo (
    var `deviceId`: kotlin.UInt
    , 
    var `label`: kotlin.String
    
){
    

    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCameraDeviceInfo: FfiConverterRustBuffer<CameraDeviceInfo> {
    override fun read(buf: ByteBuffer): CameraDeviceInfo {
        return CameraDeviceInfo(
            FfiConverterUInt.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: CameraDeviceInfo) = (
            FfiConverterUInt.allocationSize(value.`deviceId`) +
            FfiConverterString.allocationSize(value.`label`)
    )

    override fun write(value: CameraDeviceInfo, buf: ByteBuffer) {
            FfiConverterUInt.write(value.`deviceId`, buf)
            FfiConverterString.write(value.`label`, buf)
    }
}



data class CameraPreviewFrame (
    var `widthPx`: kotlin.UInt
    , 
    var `heightPx`: kotlin.UInt
    , 
    var `encoding`: CameraPreviewFrameEncoding
    , 
    var `frameBytes`: kotlin.ByteArray
    
){
    

    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCameraPreviewFrame: FfiConverterRustBuffer<CameraPreviewFrame> {
    override fun read(buf: ByteBuffer): CameraPreviewFrame {
        return CameraPreviewFrame(
            FfiConverterUInt.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterTypeCameraPreviewFrameEncoding.read(buf),
            FfiConverterByteArray.read(buf),
        )
    }

    override fun allocationSize(value: CameraPreviewFrame) = (
            FfiConverterUInt.allocationSize(value.`widthPx`) +
            FfiConverterUInt.allocationSize(value.`heightPx`) +
            FfiConverterTypeCameraPreviewFrameEncoding.allocationSize(value.`encoding`) +
            FfiConverterByteArray.allocationSize(value.`frameBytes`)
    )

    override fun write(value: CameraPreviewFrame, buf: ByteBuffer) {
            FfiConverterUInt.write(value.`widthPx`, buf)
            FfiConverterUInt.write(value.`heightPx`, buf)
            FfiConverterTypeCameraPreviewFrameEncoding.write(value.`encoding`, buf)
            FfiConverterByteArray.write(value.`frameBytes`, buf)
    }
}



data class FacetKeyDisplayHintEntry (
    var `key`: kotlin.String
    , 
    var `config`: FacetDisplayHint
    
){
    

    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeFacetKeyDisplayHintEntry: FfiConverterRustBuffer<FacetKeyDisplayHintEntry> {
    override fun read(buf: ByteBuffer): FacetKeyDisplayHintEntry {
        return FacetKeyDisplayHintEntry(
            FfiConverterString.read(buf),
            FfiConverterTypeFacetDisplayHint.read(buf),
        )
    }

    override fun allocationSize(value: FacetKeyDisplayHintEntry) = (
            FfiConverterString.allocationSize(value.`key`) +
            FfiConverterTypeFacetDisplayHint.allocationSize(value.`config`)
    )

    override fun write(value: FacetKeyDisplayHintEntry, buf: ByteBuffer) {
            FfiConverterString.write(value.`key`, buf)
            FfiConverterTypeFacetDisplayHint.write(value.`config`, buf)
    }
}



data class KnownRepoEntryFfi (
    var `id`: kotlin.String
    , 
    var `path`: kotlin.String
    , 
    var `createdAtUnixSecs`: kotlin.Long
    , 
    var `lastOpenedAtUnixSecs`: kotlin.Long
    
){
    

    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeKnownRepoEntryFfi: FfiConverterRustBuffer<KnownRepoEntryFfi> {
    override fun read(buf: ByteBuffer): KnownRepoEntryFfi {
        return KnownRepoEntryFfi(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
        )
    }

    override fun allocationSize(value: KnownRepoEntryFfi) = (
            FfiConverterString.allocationSize(value.`id`) +
            FfiConverterString.allocationSize(value.`path`) +
            FfiConverterLong.allocationSize(value.`createdAtUnixSecs`) +
            FfiConverterLong.allocationSize(value.`lastOpenedAtUnixSecs`)
    )

    override fun write(value: KnownRepoEntryFfi, buf: ByteBuffer) {
            FfiConverterString.write(value.`id`, buf)
            FfiConverterString.write(value.`path`, buf)
            FfiConverterLong.write(value.`createdAtUnixSecs`, buf)
            FfiConverterLong.write(value.`lastOpenedAtUnixSecs`, buf)
    }
}




enum class CameraPreviewFrameEncoding {
    
    JPEG,
    RGB24;

    


    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeCameraPreviewFrameEncoding: FfiConverterRustBuffer<CameraPreviewFrameEncoding> {
    override fun read(buf: ByteBuffer) = try {
        CameraPreviewFrameEncoding.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: CameraPreviewFrameEncoding) = 4UL

    override fun write(value: CameraPreviewFrameEncoding, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






/**
 * @suppress
 */
public object FfiConverterOptionalTypeFacetDisplayHint: FfiConverterRustBuffer<FacetDisplayHint?> {
    override fun read(buf: ByteBuffer): FacetDisplayHint? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeFacetDisplayHint.read(buf)
    }

    override fun allocationSize(value: FacetDisplayHint?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeFacetDisplayHint.allocationSize(value)
        }
    }

    override fun write(value: FacetDisplayHint?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeFacetDisplayHint.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypePanel: FfiConverterRustBuffer<Panel?> {
    override fun read(buf: ByteBuffer): Panel? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypePanel.read(buf)
    }

    override fun allocationSize(value: Panel?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypePanel.allocationSize(value)
        }
    }

    override fun write(value: Panel?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypePanel.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeProgressTask: FfiConverterRustBuffer<ProgressTask?> {
    override fun read(buf: ByteBuffer): ProgressTask? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeProgressTask.read(buf)
    }

    override fun allocationSize(value: ProgressTask?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeProgressTask.allocationSize(value)
        }
    }

    override fun write(value: ProgressTask?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeProgressTask.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeTab: FfiConverterRustBuffer<Tab?> {
    override fun read(buf: ByteBuffer): Tab? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeTab.read(buf)
    }

    override fun allocationSize(value: Tab?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeTab.allocationSize(value)
        }
    }

    override fun write(value: Tab?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeTab.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeTable: FfiConverterRustBuffer<Table?> {
    override fun read(buf: ByteBuffer): Table? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeTable.read(buf)
    }

    override fun allocationSize(value: Table?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeTable.allocationSize(value)
        }
    }

    override fun write(value: Table?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeTable.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeWindow: FfiConverterRustBuffer<Window?> {
    override fun read(buf: ByteBuffer): Window? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeWindow.read(buf)
    }

    override fun allocationSize(value: Window?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeWindow.allocationSize(value)
        }
    }

    override fun write(value: Window?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeWindow.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeCameraPreviewFrame: FfiConverterRustBuffer<CameraPreviewFrame?> {
    override fun read(buf: ByteBuffer): CameraPreviewFrame? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeCameraPreviewFrame.read(buf)
    }

    override fun allocationSize(value: CameraPreviewFrame?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeCameraPreviewFrame.allocationSize(value)
        }
    }

    override fun write(value: CameraPreviewFrame?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeCameraPreviewFrame.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeKnownRepoEntryFfi: FfiConverterRustBuffer<KnownRepoEntryFfi?> {
    override fun read(buf: ByteBuffer): KnownRepoEntryFfi? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeKnownRepoEntryFfi.read(buf)
    }

    override fun allocationSize(value: KnownRepoEntryFfi?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeKnownRepoEntryFfi.allocationSize(value)
        }
    }

    override fun write(value: KnownRepoEntryFfi?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeKnownRepoEntryFfi.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeDoc: FfiConverterRustBuffer<Doc?> {
    override fun read(buf: ByteBuffer): Doc? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeDoc.read(buf)
    }

    override fun allocationSize(value: Doc?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeDoc.allocationSize(value)
        }
    }

    override fun write(value: Doc?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeDoc.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeProgressRetentionPolicy: FfiConverterRustBuffer<ProgressRetentionPolicy?> {
    override fun read(buf: ByteBuffer): ProgressRetentionPolicy? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeProgressRetentionPolicy.read(buf)
    }

    override fun allocationSize(value: ProgressRetentionPolicy?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeProgressRetentionPolicy.allocationSize(value)
        }
    }

    override fun write(value: ProgressRetentionPolicy?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeProgressRetentionPolicy.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeChangeHashSet: FfiConverterRustBuffer<ChangeHashSet?> {
    override fun read(buf: ByteBuffer): ChangeHashSet? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeChangeHashSet.read(buf)
    }

    override fun allocationSize(value: ChangeHashSet?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeChangeHashSet.allocationSize(value)
        }
    }

    override fun write(value: ChangeHashSet?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeChangeHashSet.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceString: FfiConverterRustBuffer<List<kotlin.String>> {
    override fun read(buf: ByteBuffer): List<kotlin.String> {
        val len = buf.getInt()
        return List<kotlin.String>(len) {
            FfiConverterString.read(buf)
        }
    }

    override fun allocationSize(value: List<kotlin.String>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterString.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<kotlin.String>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterString.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeDocNBranches: FfiConverterRustBuffer<List<DocNBranches>> {
    override fun read(buf: ByteBuffer): List<DocNBranches> {
        val len = buf.getInt()
        return List<DocNBranches>(len) {
            FfiConverterTypeDocNBranches.read(buf)
        }
    }

    override fun allocationSize(value: List<DocNBranches>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeDocNBranches.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<DocNBranches>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeDocNBranches.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypePanel: FfiConverterRustBuffer<List<Panel>> {
    override fun read(buf: ByteBuffer): List<Panel> {
        val len = buf.getInt()
        return List<Panel>(len) {
            FfiConverterTypePanel.read(buf)
        }
    }

    override fun allocationSize(value: List<Panel>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypePanel.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Panel>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypePanel.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeProgressTask: FfiConverterRustBuffer<List<ProgressTask>> {
    override fun read(buf: ByteBuffer): List<ProgressTask> {
        val len = buf.getInt()
        return List<ProgressTask>(len) {
            FfiConverterTypeProgressTask.read(buf)
        }
    }

    override fun allocationSize(value: List<ProgressTask>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeProgressTask.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ProgressTask>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeProgressTask.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeProgressUpdateEntry: FfiConverterRustBuffer<List<ProgressUpdateEntry>> {
    override fun read(buf: ByteBuffer): List<ProgressUpdateEntry> {
        val len = buf.getInt()
        return List<ProgressUpdateEntry>(len) {
            FfiConverterTypeProgressUpdateEntry.read(buf)
        }
    }

    override fun allocationSize(value: List<ProgressUpdateEntry>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeProgressUpdateEntry.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ProgressUpdateEntry>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeProgressUpdateEntry.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeTab: FfiConverterRustBuffer<List<Tab>> {
    override fun read(buf: ByteBuffer): List<Tab> {
        val len = buf.getInt()
        return List<Tab>(len) {
            FfiConverterTypeTab.read(buf)
        }
    }

    override fun allocationSize(value: List<Tab>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeTab.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Tab>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeTab.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeTable: FfiConverterRustBuffer<List<Table>> {
    override fun read(buf: ByteBuffer): List<Table> {
        val len = buf.getInt()
        return List<Table>(len) {
            FfiConverterTypeTable.read(buf)
        }
    }

    override fun allocationSize(value: List<Table>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeTable.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Table>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeTable.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeUpdateDocArgsV2: FfiConverterRustBuffer<List<UpdateDocArgsV2>> {
    override fun read(buf: ByteBuffer): List<UpdateDocArgsV2> {
        val len = buf.getInt()
        return List<UpdateDocArgsV2>(len) {
            FfiConverterTypeUpdateDocArgsV2.read(buf)
        }
    }

    override fun allocationSize(value: List<UpdateDocArgsV2>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeUpdateDocArgsV2.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<UpdateDocArgsV2>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeUpdateDocArgsV2.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeWindow: FfiConverterRustBuffer<List<Window>> {
    override fun read(buf: ByteBuffer): List<Window> {
        val len = buf.getInt()
        return List<Window>(len) {
            FfiConverterTypeWindow.read(buf)
        }
    }

    override fun allocationSize(value: List<Window>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeWindow.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Window>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeWindow.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeCameraDeviceInfo: FfiConverterRustBuffer<List<CameraDeviceInfo>> {
    override fun read(buf: ByteBuffer): List<CameraDeviceInfo> {
        val len = buf.getInt()
        return List<CameraDeviceInfo>(len) {
            FfiConverterTypeCameraDeviceInfo.read(buf)
        }
    }

    override fun allocationSize(value: List<CameraDeviceInfo>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeCameraDeviceInfo.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<CameraDeviceInfo>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeCameraDeviceInfo.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeKnownRepoEntryFfi: FfiConverterRustBuffer<List<KnownRepoEntryFfi>> {
    override fun read(buf: ByteBuffer): List<KnownRepoEntryFfi> {
        val len = buf.getInt()
        return List<KnownRepoEntryFfi>(len) {
            FfiConverterTypeKnownRepoEntryFfi.read(buf)
        }
    }

    override fun allocationSize(value: List<KnownRepoEntryFfi>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeKnownRepoEntryFfi.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<KnownRepoEntryFfi>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeKnownRepoEntryFfi.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterMapStringTypeFacetDisplayHint: FfiConverterRustBuffer<Map<kotlin.String, FacetDisplayHint>> {
    override fun read(buf: ByteBuffer): Map<kotlin.String, FacetDisplayHint> {
        val len = buf.getInt()
        return buildMap<kotlin.String, FacetDisplayHint>(len) {
            repeat(len) {
                val k = FfiConverterString.read(buf)
                val v = FfiConverterTypeFacetDisplayHint.read(buf)
                this[k] = v
            }
        }
    }

    override fun allocationSize(value: Map<kotlin.String, FacetDisplayHint>): ULong {
        val spaceForMapSize = 4UL
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterTypeFacetDisplayHint.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<kotlin.String, FacetDisplayHint>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterTypeFacetDisplayHint.write(v, buf)
        }
    }
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias ChangeHashSet = List<kotlin.String>
public typealias FfiConverterTypeChangeHashSet = FfiConverterSequenceString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias Json = kotlin.String
public typealias FfiConverterTypeJson = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias PathBuf = kotlin.String
public typealias FfiConverterTypePathBuf = FfiConverterString





/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias Timestamp = Instant


/**
 * @suppress
 */
public object FfiConverterTypeTimestamp: FfiConverter<Timestamp, Long> {
    override fun lift(value: Long): Timestamp {
        val builtinValue = FfiConverterLong.lift(value)
        return Instant.fromEpochSeconds(builtinValue, 0)
    }

    override fun lower(value: Timestamp): Long {
        val builtinValue = value.epochSeconds
        return FfiConverterLong.lower(builtinValue)
    }

    override fun read(buf: ByteBuffer): Timestamp {
        val builtinValue = FfiConverterLong.read(buf)
        return Instant.fromEpochSeconds(builtinValue, 0)
    }

    override fun allocationSize(value: Timestamp): ULong {
        val builtinValue = value.epochSeconds
        return FfiConverterLong.allocationSize(builtinValue)
    }

    override fun write(value: Timestamp, buf: ByteBuffer) {
        val builtinValue = value.epochSeconds
        FfiConverterLong.write(builtinValue, buf)
    }
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias Url = kotlin.String
public typealias FfiConverterTypeUrl = FfiConverterString





/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias Uuid = Uuid


/**
 * @suppress
 */
public object FfiConverterTypeUuid: FfiConverter<Uuid, RustBuffer.ByValue> {
    override fun lift(value: RustBuffer.ByValue): Uuid {
        val builtinValue = FfiConverterByteArray.lift(value)
        return Uuid.fromByteArray(builtinValue)
    }

    override fun lower(value: Uuid): RustBuffer.ByValue {
        val builtinValue = value.toByteArray()
        return FfiConverterByteArray.lower(builtinValue)
    }

    override fun read(buf: ByteBuffer): Uuid {
        val builtinValue = FfiConverterByteArray.read(buf)
        return Uuid.fromByteArray(builtinValue)
    }

    override fun allocationSize(value: Uuid): ULong {
        val builtinValue = value.toByteArray()
        return FfiConverterByteArray.allocationSize(builtinValue)
    }

    override fun write(value: Uuid, buf: ByteBuffer) {
        val builtinValue = value.toByteArray()
        FfiConverterByteArray.write(builtinValue, buf)
    }
}
